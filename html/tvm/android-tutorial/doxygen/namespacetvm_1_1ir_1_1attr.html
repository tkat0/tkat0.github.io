<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::ir::attr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1ir.html">ir</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1ir_1_1attr.html">attr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::ir::attr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace of possible attribute sin AttrStmt.attr_key  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adeec810b3c8bd3f473e2a4d0c5f511ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#adeec810b3c8bd3f473e2a4d0c5f511ac">IsPragmaKey</a> (const std::string &amp;attr_key)</td></tr>
<tr class="memdesc:adeec810b3c8bd3f473e2a4d0c5f511ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if attr_key is a pragma key extension.  <a href="#adeec810b3c8bd3f473e2a4d0c5f511ac">More...</a><br /></td></tr>
<tr class="separator:adeec810b3c8bd3f473e2a4d0c5f511ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6209c579bf44685d47de5d41c039bef3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a6209c579bf44685d47de5d41c039bef3">thread_extent</a> = &quot;thread_extent&quot;</td></tr>
<tr class="memdesc:a6209c579bf44685d47de5d41c039bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching extent of thread, used by device API.  <a href="#a6209c579bf44685d47de5d41c039bef3">More...</a><br /></td></tr>
<tr class="separator:a6209c579bf44685d47de5d41c039bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1e73afd68534627978dcef4ade76f9"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#acc1e73afd68534627978dcef4ade76f9">virtual_thread</a> = &quot;virtual_thread&quot;</td></tr>
<tr class="memdesc:acc1e73afd68534627978dcef4ade76f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching of a virtual thread.  <a href="#acc1e73afd68534627978dcef4ade76f9">More...</a><br /></td></tr>
<tr class="separator:acc1e73afd68534627978dcef4ade76f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e94e651c4d72580f80c1b13bc9965"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a2b3e94e651c4d72580f80c1b13bc9965">coproc_scope</a> = &quot;coproc_scope&quot;</td></tr>
<tr class="memdesc:a2b3e94e651c4d72580f80c1b13bc9965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is processed by a co-proccesor.  <a href="#a2b3e94e651c4d72580f80c1b13bc9965">More...</a><br /></td></tr>
<tr class="separator:a2b3e94e651c4d72580f80c1b13bc9965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e45d785126115cfa24ae2f69e316dd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a30e45d785126115cfa24ae2f69e316dd">coproc_uop_scope</a> = &quot;coproc_uop_scope&quot;</td></tr>
<tr class="memdesc:a30e45d785126115cfa24ae2f69e316dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent.  <a href="#a30e45d785126115cfa24ae2f69e316dd">More...</a><br /></td></tr>
<tr class="separator:a30e45d785126115cfa24ae2f69e316dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1800ebc9fe2a26c617451bcd79e48f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#ade1800ebc9fe2a26c617451bcd79e48f">volatile_scope</a> = &quot;volatile_scope&quot;</td></tr>
<tr class="memdesc:ade1800ebc9fe2a26c617451bcd79e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as volatile access for certain handle.  <a href="#ade1800ebc9fe2a26c617451bcd79e48f">More...</a><br /></td></tr>
<tr class="separator:ade1800ebc9fe2a26c617451bcd79e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddf07fea691466fc9801ca4ba53aa52"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a9ddf07fea691466fc9801ca4ba53aa52">extern_scope</a> = &quot;extern_scope&quot;</td></tr>
<tr class="memdesc:a9ddf07fea691466fc9801ca4ba53aa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program.  <a href="#a9ddf07fea691466fc9801ca4ba53aa52">More...</a><br /></td></tr>
<tr class="separator:a9ddf07fea691466fc9801ca4ba53aa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094faa1fe14469337939ba156871a181"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a094faa1fe14469337939ba156871a181">compute_scope</a> = &quot;compute_scope&quot;</td></tr>
<tr class="memdesc:a094faa1fe14469337939ba156871a181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute.  <a href="#a094faa1fe14469337939ba156871a181">More...</a><br /></td></tr>
<tr class="separator:a094faa1fe14469337939ba156871a181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ed5551ea490efd4242cfb472f1d6fa"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#ac4ed5551ea490efd4242cfb472f1d6fa">storage_scope</a> = &quot;storage_scope&quot;</td></tr>
<tr class="memdesc:ac4ed5551ea490efd4242cfb472f1d6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of buffers.  <a href="#ac4ed5551ea490efd4242cfb472f1d6fa">More...</a><br /></td></tr>
<tr class="separator:ac4ed5551ea490efd4242cfb472f1d6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a568e9e1beb3a5e15ba34a6c74cbbe"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#af9a568e9e1beb3a5e15ba34a6c74cbbe">storage_alignment</a> = &quot;storage_alignment&quot;</td></tr>
<tr class="memdesc:af9a568e9e1beb3a5e15ba34a6c74cbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage alignement requirement of buffers.  <a href="#af9a568e9e1beb3a5e15ba34a6c74cbbe">More...</a><br /></td></tr>
<tr class="separator:af9a568e9e1beb3a5e15ba34a6c74cbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70b1e1094073be862a47588117f1f5c"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#ae70b1e1094073be862a47588117f1f5c">realize_scope</a> = &quot;realize_scope&quot;</td></tr>
<tr class="memdesc:ae70b1e1094073be862a47588117f1f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of realization.  <a href="#ae70b1e1094073be862a47588117f1f5c">More...</a><br /></td></tr>
<tr class="separator:ae70b1e1094073be862a47588117f1f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc6c3e6de3d48d37fbac9ccf95660b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#aaabc6c3e6de3d48d37fbac9ccf95660b">device_context_id</a> = &quot;device_context_id&quot;</td></tr>
<tr class="memdesc:aaabc6c3e6de3d48d37fbac9ccf95660b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation context for global malloc in host.  <a href="#aaabc6c3e6de3d48d37fbac9ccf95660b">More...</a><br /></td></tr>
<tr class="separator:aaabc6c3e6de3d48d37fbac9ccf95660b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d121bfca3deb84c78e43cd8280d3ea8"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a0d121bfca3deb84c78e43cd8280d3ea8">device_context_type</a> = &quot;device_context_type&quot;</td></tr>
<tr class="memdesc:a0d121bfca3deb84c78e43cd8280d3ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type.  <a href="#a0d121bfca3deb84c78e43cd8280d3ea8">More...</a><br /></td></tr>
<tr class="separator:a0d121bfca3deb84c78e43cd8280d3ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15090b50d045c61c40673df7e74be4fb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a15090b50d045c61c40673df7e74be4fb">loop_scope</a> = &quot;loop_scope&quot;</td></tr>
<tr class="memdesc:a15090b50d045c61c40673df7e74be4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of loop scope.  <a href="#a15090b50d045c61c40673df7e74be4fb">More...</a><br /></td></tr>
<tr class="separator:a15090b50d045c61c40673df7e74be4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db1e52adcef7e7eca7d227423a8a065"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a8db1e52adcef7e7eca7d227423a8a065">reduce_scope</a> = &quot;reduce_scope&quot;</td></tr>
<tr class="memdesc:a8db1e52adcef7e7eca7d227423a8a065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of reduce scope.  <a href="#a8db1e52adcef7e7eca7d227423a8a065">More...</a><br /></td></tr>
<tr class="separator:a8db1e52adcef7e7eca7d227423a8a065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3ed9c420da59a425db97bdf6dd9f93"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#aba3ed9c420da59a425db97bdf6dd9f93">pragma_scope_prefix</a> = &quot;pragma_&quot;</td></tr>
<tr class="memdesc:aba3ed9c420da59a425db97bdf6dd9f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is guarded by the pragma extension.  <a href="#aba3ed9c420da59a425db97bdf6dd9f93">More...</a><br /></td></tr>
<tr class="separator:aba3ed9c420da59a425db97bdf6dd9f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315fa530734d13c04985191c5d8fea0f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a315fa530734d13c04985191c5d8fea0f">pragma_import_llvm</a> = &quot;pragma_import_llvm&quot;</td></tr>
<tr class="memdesc:a315fa530734d13c04985191c5d8fea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import llvm source or file into the final code gen module.  <a href="#a315fa530734d13c04985191c5d8fea0f">More...</a><br /></td></tr>
<tr class="separator:a315fa530734d13c04985191c5d8fea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a4b9618f1ae3e110c0a90b1b117d35"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a48a4b9618f1ae3e110c0a90b1b117d35">prefetch_scope</a> = &quot;prefetch_scope&quot;</td></tr>
<tr class="memdesc:a48a4b9618f1ae3e110c0a90b1b117d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of prefetch scope, value=offset, run prefetch of <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> on the current loop scope.  <a href="#a48a4b9618f1ae3e110c0a90b1b117d35">More...</a><br /></td></tr>
<tr class="separator:a48a4b9618f1ae3e110c0a90b1b117d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16af3779bb39ee706b6cd5698705d1b9"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a16af3779bb39ee706b6cd5698705d1b9">double_buffer_scope</a> = &quot;double_buffer_scope&quot;</td></tr>
<tr class="memdesc:a16af3779bb39ee706b6cd5698705d1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks production of double buffer data.  <a href="#a16af3779bb39ee706b6cd5698705d1b9">More...</a><br /></td></tr>
<tr class="separator:a16af3779bb39ee706b6cd5698705d1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df8038bbeb2ad9ba95ee107b13aaa7a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a6df8038bbeb2ad9ba95ee107b13aaa7a">double_buffer_write</a> = &quot;double_buffer_write&quot;</td></tr>
<tr class="memdesc:a6df8038bbeb2ad9ba95ee107b13aaa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks region used by double buffer write.  <a href="#a6df8038bbeb2ad9ba95ee107b13aaa7a">More...</a><br /></td></tr>
<tr class="separator:a6df8038bbeb2ad9ba95ee107b13aaa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7852f52fcfff7c122e336c24f6a294e4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a7852f52fcfff7c122e336c24f6a294e4">scan_update_scope</a> = &quot;scan_update_scope&quot;</td></tr>
<tr class="memdesc:a7852f52fcfff7c122e336c24f6a294e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan update scope.  <a href="#a7852f52fcfff7c122e336c24f6a294e4">More...</a><br /></td></tr>
<tr class="separator:a7852f52fcfff7c122e336c24f6a294e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c95e0af1e6bd49f2b10251bd9f686f"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#ad5c95e0af1e6bd49f2b10251bd9f686f">scan_init_scope</a> = &quot;scan_init_scope&quot;</td></tr>
<tr class="memdesc:ad5c95e0af1e6bd49f2b10251bd9f686f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan init scope.  <a href="#ad5c95e0af1e6bd49f2b10251bd9f686f">More...</a><br /></td></tr>
<tr class="separator:ad5c95e0af1e6bd49f2b10251bd9f686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eaeb0a38a62b1dc904829f67465cf8"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#ad2eaeb0a38a62b1dc904829f67465cf8">buffer_dim_align</a> = &quot;buffer_dim_align&quot;</td></tr>
<tr class="memdesc:ad2eaeb0a38a62b1dc904829f67465cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark alignment of buffer dimension stmt.node is <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset.  <a href="#ad2eaeb0a38a62b1dc904829f67465cf8">More...</a><br /></td></tr>
<tr class="separator:ad2eaeb0a38a62b1dc904829f67465cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e268ee7308bcadcbe45d7744b4b46c6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a0e268ee7308bcadcbe45d7744b4b46c6">buffer_bound</a> = &quot;buffer_bound&quot;</td></tr>
<tr class="memdesc:a0e268ee7308bcadcbe45d7744b4b46c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark stores/loads with theirs bounds.  <a href="#a0e268ee7308bcadcbe45d7744b4b46c6">More...</a><br /></td></tr>
<tr class="separator:a0e268ee7308bcadcbe45d7744b4b46c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cca552eeac9955a4d4a128193f45c0"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a60cca552eeac9955a4d4a128193f45c0">buffer_bind_scope</a> = &quot;buffer_bind_scope&quot;</td></tr>
<tr class="memdesc:a60cca552eeac9955a4d4a128193f45c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase.  <a href="#a60cca552eeac9955a4d4a128193f45c0">More...</a><br /></td></tr>
<tr class="separator:a60cca552eeac9955a4d4a128193f45c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a9b41b3c0a5d078806e78f7736be8a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a46a9b41b3c0a5d078806e78f7736be8a">channel_read_scope</a> = &quot;channel_read_scope&quot;</td></tr>
<tr class="memdesc:a46a9b41b3c0a5d078806e78f7736be8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel read scope  <a href="#a46a9b41b3c0a5d078806e78f7736be8a">More...</a><br /></td></tr>
<tr class="separator:a46a9b41b3c0a5d078806e78f7736be8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e022558375f140b5eefa527db0497c4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a3e022558375f140b5eefa527db0497c4">channel_read_advance</a> = &quot;channel_read_advance&quot;</td></tr>
<tr class="memdesc:a3e022558375f140b5eefa527db0497c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#a3e022558375f140b5eefa527db0497c4">More...</a><br /></td></tr>
<tr class="separator:a3e022558375f140b5eefa527db0497c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c233b6714beb86d08ba141165e826dc"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a5c233b6714beb86d08ba141165e826dc">channel_write_scope</a> = &quot;channel_write_scope&quot;</td></tr>
<tr class="memdesc:a5c233b6714beb86d08ba141165e826dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel write scope  <a href="#a5c233b6714beb86d08ba141165e826dc">More...</a><br /></td></tr>
<tr class="separator:a5c233b6714beb86d08ba141165e826dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296e54b4069977806baefc3ad7c64d06"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a296e54b4069977806baefc3ad7c64d06">channel_write_advance</a> = &quot;channel_write_advance&quot;</td></tr>
<tr class="memdesc:a296e54b4069977806baefc3ad7c64d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="#a296e54b4069977806baefc3ad7c64d06">More...</a><br /></td></tr>
<tr class="separator:a296e54b4069977806baefc3ad7c64d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8082a903724e9a0c3d25cc93ac07af22"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a8082a903724e9a0c3d25cc93ac07af22">pipeline_stage_scope</a> = &quot;pipeline_stage_scope&quot;</td></tr>
<tr class="memdesc:a8082a903724e9a0c3d25cc93ac07af22"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline stage scope, implies always execution  <a href="#a8082a903724e9a0c3d25cc93ac07af22">More...</a><br /></td></tr>
<tr class="separator:a8082a903724e9a0c3d25cc93ac07af22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395f0eba6cd55a7eeff08823fcaee009"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a395f0eba6cd55a7eeff08823fcaee009">pipeline_exec_scope</a> = &quot;pipeline_exec_scope&quot;</td></tr>
<tr class="memdesc:a395f0eba6cd55a7eeff08823fcaee009"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline execution scope, implies the scope can be pipelined.  <a href="#a395f0eba6cd55a7eeff08823fcaee009">More...</a><br /></td></tr>
<tr class="separator:a395f0eba6cd55a7eeff08823fcaee009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28604eb6df07b598162f07105a28139e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a28604eb6df07b598162f07105a28139e">opengl_stage_scope</a> = &quot;opengl_stage_scope&quot;</td></tr>
<tr class="memdesc:a28604eb6df07b598162f07105a28139e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that this stage is an OpenGL shader. Since OpenGL shader only allows writing out to one element of the output texture, the Provide node gets translated to a special Call::glsl_texture_store statement instead of a Store statement.  <a href="#a28604eb6df07b598162f07105a28139e">More...</a><br /></td></tr>
<tr class="separator:a28604eb6df07b598162f07105a28139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a57caba45aa41f4008690c2f94b5892"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html#a0a57caba45aa41f4008690c2f94b5892">device_scope</a> = &quot;device_scope&quot;</td></tr>
<tr class="memdesc:a0a57caba45aa41f4008690c2f94b5892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that it is in the device scope.  <a href="#a0a57caba45aa41f4008690c2f94b5892">More...</a><br /></td></tr>
<tr class="separator:a0a57caba45aa41f4008690c2f94b5892"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace of possible attribute sin AttrStmt.attr_key </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adeec810b3c8bd3f473e2a4d0c5f511ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::attr::IsPragmaKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if attr_key is a pragma key extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_key</td><td>The attr key to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is a pragma key </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a60cca552eeac9955a4d4a128193f45c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::buffer_bind_scope = &quot;buffer_bind_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase. </p>

</div>
</div>
<a class="anchor" id="a0e268ee7308bcadcbe45d7744b4b46c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::buffer_bound = &quot;buffer_bound&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark stores/loads with theirs bounds. </p>

</div>
</div>
<a class="anchor" id="ad2eaeb0a38a62b1dc904829f67465cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::buffer_dim_align = &quot;buffer_dim_align&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark alignment of buffer dimension stmt.node is <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset. </p>

</div>
</div>
<a class="anchor" id="a3e022558375f140b5eefa527db0497c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::channel_read_advance = &quot;channel_read_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a class="anchor" id="a46a9b41b3c0a5d078806e78f7736be8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::channel_read_scope = &quot;channel_read_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel read scope </p>

</div>
</div>
<a class="anchor" id="a296e54b4069977806baefc3ad7c64d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::channel_write_advance = &quot;channel_write_advance&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance step of channel after end of scope. </p>

</div>
</div>
<a class="anchor" id="a5c233b6714beb86d08ba141165e826dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::channel_write_scope = &quot;channel_write_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>channel write scope </p>

</div>
</div>
<a class="anchor" id="a094faa1fe14469337939ba156871a181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::compute_scope = &quot;compute_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute. </p>

</div>
</div>
<a class="anchor" id="a2b3e94e651c4d72580f80c1b13bc9965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::coproc_scope = &quot;coproc_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is processed by a co-proccesor. </p>

</div>
</div>
<a class="anchor" id="a30e45d785126115cfa24ae2f69e316dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::coproc_uop_scope = &quot;coproc_uop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent. </p>

</div>
</div>
<a class="anchor" id="aaabc6c3e6de3d48d37fbac9ccf95660b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::device_context_id = &quot;device_context_id&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The allocation context for global malloc in host. </p>

</div>
</div>
<a class="anchor" id="a0d121bfca3deb84c78e43cd8280d3ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::device_context_type = &quot;device_context_type&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device type. </p>

</div>
</div>
<a class="anchor" id="a0a57caba45aa41f4008690c2f94b5892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::device_scope = &quot;device_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that it is in the device scope. </p>

</div>
</div>
<a class="anchor" id="a16af3779bb39ee706b6cd5698705d1b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::double_buffer_scope = &quot;double_buffer_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks production of double buffer data. </p>

</div>
</div>
<a class="anchor" id="a6df8038bbeb2ad9ba95ee107b13aaa7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::double_buffer_write = &quot;double_buffer_write&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks region used by double buffer write. </p>

</div>
</div>
<a class="anchor" id="a9ddf07fea691466fc9801ca4ba53aa52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::extern_scope = &quot;extern_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program. </p>

</div>
</div>
<a class="anchor" id="a15090b50d045c61c40673df7e74be4fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::loop_scope = &quot;loop_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of loop scope. </p>

</div>
</div>
<a class="anchor" id="a28604eb6df07b598162f07105a28139e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::opengl_stage_scope = &quot;opengl_stage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that this stage is an OpenGL shader. Since OpenGL shader only allows writing out to one element of the output texture, the Provide node gets translated to a special Call::glsl_texture_store statement instead of a Store statement. </p>

</div>
</div>
<a class="anchor" id="a395f0eba6cd55a7eeff08823fcaee009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::pipeline_exec_scope = &quot;pipeline_exec_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline execution scope, implies the scope can be pipelined. </p>

</div>
</div>
<a class="anchor" id="a8082a903724e9a0c3d25cc93ac07af22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::pipeline_stage_scope = &quot;pipeline_stage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pipeline stage scope, implies always execution </p>

</div>
</div>
<a class="anchor" id="a315fa530734d13c04985191c5d8fea0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::pragma_import_llvm = &quot;pragma_import_llvm&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import llvm source or file into the final code gen module. </p>

</div>
</div>
<a class="anchor" id="aba3ed9c420da59a425db97bdf6dd9f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::pragma_scope_prefix = &quot;pragma_&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark region is guarded by the pragma extension. </p>

</div>
</div>
<a class="anchor" id="a48a4b9618f1ae3e110c0a90b1b117d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::prefetch_scope = &quot;prefetch_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of prefetch scope, value=offset, run prefetch of <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> on the current loop scope. </p>

</div>
</div>
<a class="anchor" id="ae70b1e1094073be862a47588117f1f5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::realize_scope = &quot;realize_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage scope of realization. </p>

</div>
</div>
<a class="anchor" id="a8db1e52adcef7e7eca7d227423a8a065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::reduce_scope = &quot;reduce_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of reduce scope. </p>

</div>
</div>
<a class="anchor" id="ad5c95e0af1e6bd49f2b10251bd9f686f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::scan_init_scope = &quot;scan_init_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan init scope. </p>

</div>
</div>
<a class="anchor" id="a7852f52fcfff7c122e336c24f6a294e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::scan_update_scope = &quot;scan_update_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark of scan update scope. </p>

</div>
</div>
<a class="anchor" id="af9a568e9e1beb3a5e15ba34a6c74cbbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::storage_alignment = &quot;storage_alignment&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage alignement requirement of buffers. </p>

</div>
</div>
<a class="anchor" id="ac4ed5551ea490efd4242cfb472f1d6fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::storage_scope = &quot;storage_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark storage scope of buffers. </p>

</div>
</div>
<a class="anchor" id="a6209c579bf44685d47de5d41c039bef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::thread_extent = &quot;thread_extent&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching extent of thread, used by device API. </p>

</div>
</div>
<a class="anchor" id="acc1e73afd68534627978dcef4ade76f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::virtual_thread = &quot;virtual_thread&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark launching of a virtual thread. </p>

</div>
</div>
<a class="anchor" id="ade1800ebc9fe2a26c617451bcd79e48f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* tvm::ir::attr::volatile_scope = &quot;volatile_scope&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the scope as volatile access for certain handle. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 6 2019 11:14:41 for tvm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
