<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: nnvm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nnvm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacennvm_1_1compiler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm_1_1compiler.html">compiler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacennvm_1_1pass"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm_1_1pass.html">pass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacennvm_1_1top"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm_1_1top.html">top</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic computation graph. This is the intermediate representation for optimization pass.  <a href="classnnvm_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1IndexedGraph.html">IndexedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary data structure to index a graph. It maps Nodes in the graph to consecutive integers node_id. It also maps <a class="el" href="structnnvm_1_1IndexedGraph_1_1NodeEntry.html" title="represents a data in the graph ">IndexedGraph::NodeEntry</a> to consecutive integer entry_id. This allows storing properties of <a class="el" href="structnnvm_1_1IndexedGraph_1_1Node.html" title="Node data structure in IndexedGraph. ">Node</a> and <a class="el" href="structnnvm_1_1IndexedGraph_1_1NodeEntry.html" title="represents a data in the graph ">NodeEntry</a> into compact vector and quickly access them without resorting to hashmap.  <a href="classnnvm_1_1IndexedGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1Layout.html">Layout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnnvm_1_1Node.html" title="Node represents an operation in a computation graph. ">Node</a> represents an operation in a computation graph.  <a href="classnnvm_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The attributes of the current operation node. Usually are additional parameters like axis,.  <a href="structnnvm_1_1NodeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an entry that represents output data from a node  <a href="structnnvm_1_1NodeEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnnvm_1_1NodeEntryEqual.html">NodeEntryEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lets you use a <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> as a key in a unordered_map of the form unordered_map&lt;NodeEntry, ValueType, NodeEntryHash, NodeEntryEqual&gt;  <a href="structnnvm_1_1NodeEntryEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnnvm_1_1NodeEntryHash.html">NodeEntryHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lets you use a <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> as a key in a unordered_map of the form unordered_map&lt;NodeEntry, ValueType, NodeEntryHash, NodeEntryEqual&gt;  <a href="structnnvm_1_1NodeEntryHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator structure.  <a href="classnnvm_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1OpGroup.html">OpGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">auxiliary data structure used to set attributes to a group of operators  <a href="classnnvm_1_1OpGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1OpMap.html">OpMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map data structure that takes Op* as key and returns ValueType.  <a href="classnnvm_1_1OpMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnnvm_1_1PassFunctionReg.html">PassFunctionReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registry entry for pass functions.  <a href="structnnvm_1_1PassFunctionReg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1Symbol.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnnvm_1_1Symbol.html" title="Symbol is help class used to represent the operator node in Graph. ">Symbol</a> is help class used to represent the operator node in <a class="el" href="classnnvm_1_1Graph.html" title="Symbolic computation graph. This is the intermediate representation for optimization pass...">Graph</a>.  <a href="classnnvm_1_1Symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1TShape.html">TShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Shape class that is used to represent shape of each tensor.  <a href="classnnvm_1_1TShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnnvm_1_1Tuple.html">Tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic sized array data structure that is optimized for storing small number of elements with same type.  <a href="classnnvm_1_1Tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2dd0c9e8b1f22efb36a05956ec22af55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a2dd0c9e8b1f22efb36a05956ec22af55">JSONString</a> = std::string</td></tr>
<tr class="memdesc:a2dd0c9e8b1f22efb36a05956ec22af55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of JSON serializer.  <a href="#a2dd0c9e8b1f22efb36a05956ec22af55">More...</a><br /></td></tr>
<tr class="separator:a2dd0c9e8b1f22efb36a05956ec22af55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a000cfbb76bfc17042b49ef30fe36f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a77a000cfbb76bfc17042b49ef30fe36f">ShapeVector</a> = std::vector&lt; <a class="el" href="classnnvm_1_1TShape.html">TShape</a> &gt;</td></tr>
<tr class="memdesc:a77a000cfbb76bfc17042b49ef30fe36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of shape of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph.  <a href="#a77a000cfbb76bfc17042b49ef30fe36f">More...</a><br /></td></tr>
<tr class="separator:a77a000cfbb76bfc17042b49ef30fe36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3047555e6bce725a8abba02b4155de9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#af3047555e6bce725a8abba02b4155de9">DTypeVector</a> = std::vector&lt; int &gt;</td></tr>
<tr class="memdesc:af3047555e6bce725a8abba02b4155de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of type of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph.  <a href="#af3047555e6bce725a8abba02b4155de9">More...</a><br /></td></tr>
<tr class="separator:af3047555e6bce725a8abba02b4155de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64589af0262bef2f459d1570628b85da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a64589af0262bef2f459d1570628b85da">LayoutVector</a> = std::vector&lt; <a class="el" href="classnnvm_1_1Layout.html">Layout</a> &gt;</td></tr>
<tr class="memdesc:a64589af0262bef2f459d1570628b85da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of layout of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph.  <a href="#a64589af0262bef2f459d1570628b85da">More...</a><br /></td></tr>
<tr class="separator:a64589af0262bef2f459d1570628b85da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94df41af9f53acd922091f62baab0f81"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a94df41af9f53acd922091f62baab0f81">DeviceVector</a> = std::vector&lt; int &gt;</td></tr>
<tr class="memdesc:a94df41af9f53acd922091f62baab0f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of device of each operator in the graph.  <a href="#a94df41af9f53acd922091f62baab0f81">More...</a><br /></td></tr>
<tr class="separator:a94df41af9f53acd922091f62baab0f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d908d5e1bfdbd544f1b6d2c99682cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a52d908d5e1bfdbd544f1b6d2c99682cc">DeviceAssignMap</a> = std::unordered_map&lt; std::string, int &gt;</td></tr>
<tr class="memdesc:a52d908d5e1bfdbd544f1b6d2c99682cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of device of each operator in the graph.  <a href="#a52d908d5e1bfdbd544f1b6d2c99682cc">More...</a><br /></td></tr>
<tr class="separator:a52d908d5e1bfdbd544f1b6d2c99682cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab8a09faa366b06b78d31c65f620af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#ad3ab8a09faa366b06b78d31c65f620af">StorageVector</a> = std::vector&lt; int &gt;</td></tr>
<tr class="memdesc:ad3ab8a09faa366b06b78d31c65f620af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result holder of storage id of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph.  <a href="#ad3ab8a09faa366b06b78d31c65f620af">More...</a><br /></td></tr>
<tr class="separator:ad3ab8a09faa366b06b78d31c65f620af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4259d4f89d9f0feb94111a1c8cb5a1ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">NodePtr</a> = std::shared_ptr&lt; <a class="el" href="classnnvm_1_1Node.html">Node</a> &gt;</td></tr>
<tr class="memdesc:a4259d4f89d9f0feb94111a1c8cb5a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">we always used NodePtr for a reference pointer to the node, so this alias can be changed in case.  <a href="#a4259d4f89d9f0feb94111a1c8cb5a1ae">More...</a><br /></td></tr>
<tr class="separator:a4259d4f89d9f0feb94111a1c8cb5a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90679a7e880dbf3f009d8d5bfc99c8d4"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a90679a7e880dbf3f009d8d5bfc99c8d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a90679a7e880dbf3f009d8d5bfc99c8d4">NodeEntryMap</a> = std::unordered_map&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a>, ValueType, <a class="el" href="structnnvm_1_1NodeEntryHash.html">NodeEntryHash</a>, <a class="el" href="structnnvm_1_1NodeEntryEqual.html">NodeEntryEqual</a> &gt;</td></tr>
<tr class="separator:a90679a7e880dbf3f009d8d5bfc99c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b811999ef6b9e8a789e2c359642738a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a5b811999ef6b9e8a789e2c359642738a">FListInputNames</a> = std::function&lt; std::vector&lt; std::string &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a5b811999ef6b9e8a789e2c359642738a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of input arguments names of each operator.  <a href="#a5b811999ef6b9e8a789e2c359642738a">More...</a><br /></td></tr>
<tr class="separator:a5b811999ef6b9e8a789e2c359642738a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475e6d8a1f6f0f63977e0b2e2a8b0ef7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a475e6d8a1f6f0f63977e0b2e2a8b0ef7">FNumVisibleOutputs</a> = std::function&lt; uint32_t(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a475e6d8a1f6f0f63977e0b2e2a8b0ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of visible outputs by the user.  <a href="#a475e6d8a1f6f0f63977e0b2e2a8b0ef7">More...</a><br /></td></tr>
<tr class="separator:a475e6d8a1f6f0f63977e0b2e2a8b0ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4188d4a9d1daecdecb9b0136b9ff3e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#af4188d4a9d1daecdecb9b0136b9ff3e7">FListOutputNames</a> = std::function&lt; std::vector&lt; std::string &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:af4188d4a9d1daecdecb9b0136b9ff3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of output arguments names of each operator.  <a href="#af4188d4a9d1daecdecb9b0136b9ff3e7">More...</a><br /></td></tr>
<tr class="separator:af4188d4a9d1daecdecb9b0136b9ff3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f43958d8171a8f2ab11880192b7125"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a12f43958d8171a8f2ab11880192b7125">FMutateInputs</a> = std::function&lt; std::vector&lt; uint32_t &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a12f43958d8171a8f2ab11880192b7125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether operator will mutate k-th input.  <a href="#a12f43958d8171a8f2ab11880192b7125">More...</a><br /></td></tr>
<tr class="separator:a12f43958d8171a8f2ab11880192b7125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a12a38eb8f3ac625170e8be2099d57"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a39a12a38eb8f3ac625170e8be2099d57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">FInferNodeEntryAttr</a> = std::function&lt; bool(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs, std::vector&lt; AttrType &gt; *in_attrs, std::vector&lt; AttrType &gt; *out_attrs)&gt;</td></tr>
<tr class="memdesc:a39a12a38eb8f3ac625170e8be2099d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inference function of certain type.  <a href="#a39a12a38eb8f3ac625170e8be2099d57">More...</a><br /></td></tr>
<tr class="separator:a39a12a38eb8f3ac625170e8be2099d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04d7b8e69e50b67769cb496c15b5fce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#ac04d7b8e69e50b67769cb496c15b5fce">FGetAttrDict</a> = std::function&lt; std::unordered_map&lt; std::string, std::string &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:ac04d7b8e69e50b67769cb496c15b5fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attribute dictionary from node.  <a href="#ac04d7b8e69e50b67769cb496c15b5fce">More...</a><br /></td></tr>
<tr class="separator:ac04d7b8e69e50b67769cb496c15b5fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80cd6cc2432e36350ad84335d5e5308"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#ae80cd6cc2432e36350ad84335d5e5308">FInferShape</a> = <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">FInferNodeEntryAttr</a>&lt; <a class="el" href="classnnvm_1_1TShape.html">TShape</a> &gt;</td></tr>
<tr class="memdesc:ae80cd6cc2432e36350ad84335d5e5308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape inference function. Update the shapes given the input shape information. <a class="el" href="classnnvm_1_1Tuple.html#ab0525b3d997b77dfd5c6b35299b250f6">TShape.ndim()</a> == 0 means the shape is still unknown.  <a href="#ae80cd6cc2432e36350ad84335d5e5308">More...</a><br /></td></tr>
<tr class="separator:ae80cd6cc2432e36350ad84335d5e5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539f5c3067c4c3cd7dbbdd6b6a6f165"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a6539f5c3067c4c3cd7dbbdd6b6a6f165">FInferType</a> = <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">FInferNodeEntryAttr</a>&lt; int &gt;</td></tr>
<tr class="memdesc:a6539f5c3067c4c3cd7dbbdd6b6a6f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type inference function. Update the type given the known type information.  <a href="#a6539f5c3067c4c3cd7dbbdd6b6a6f165">More...</a><br /></td></tr>
<tr class="separator:a6539f5c3067c4c3cd7dbbdd6b6a6f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac317e6034c26f9cb453e91cd38e35df9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#ac317e6034c26f9cb453e91cd38e35df9">TIsBackward</a> = bool</td></tr>
<tr class="memdesc:ac317e6034c26f9cb453e91cd38e35df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this op is an explicit backward operator, If TIsBackward is true:  <a href="#ac317e6034c26f9cb453e91cd38e35df9">More...</a><br /></td></tr>
<tr class="separator:ac317e6034c26f9cb453e91cd38e35df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4bdafc4a28981d4d9b5fc8207fc04c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a7d4bdafc4a28981d4d9b5fc8207fc04c">FInplaceOption</a> = std::function&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a7d4bdafc4a28981d4d9b5fc8207fc04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get possible inplace options. This function enables optimization to reuse memory of inputs in output.  <a href="#a7d4bdafc4a28981d4d9b5fc8207fc04c">More...</a><br /></td></tr>
<tr class="separator:a7d4bdafc4a28981d4d9b5fc8207fc04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ef67828f4ddb6c7aea2e3b1b685d90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a39ef67828f4ddb6c7aea2e3b1b685d90">FInplaceIdentity</a> = std::function&lt; std::vector&lt; bool &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:a39ef67828f4ddb6c7aea2e3b1b685d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if the inplace option is an identity This function enables inplace optimization even when input reference count is greater than one.  <a href="#a39ef67828f4ddb6c7aea2e3b1b685d90">More...</a><br /></td></tr>
<tr class="separator:a39ef67828f4ddb6c7aea2e3b1b685d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab951c7d30fcc4f17ffddbfd082d24792"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#ab951c7d30fcc4f17ffddbfd082d24792">FIgnoreInputs</a> = std::function&lt; std::vector&lt; uint32_t &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:ab951c7d30fcc4f17ffddbfd082d24792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of inputs in the op whose content are actually not used by the operator These are dummy input that can be used for example in zeros_like, ones_like.  <a href="#ab951c7d30fcc4f17ffddbfd082d24792">More...</a><br /></td></tr>
<tr class="separator:ab951c7d30fcc4f17ffddbfd082d24792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6152342e9cf75f9a0213d87e9aa14fa2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a6152342e9cf75f9a0213d87e9aa14fa2">FGradient</a> = std::function&lt; std::vector&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> &gt;(const <a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">NodePtr</a> &amp;nodeptr, const std::vector&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> &gt; &amp;out_grads)&gt;</td></tr>
<tr class="memdesc:a6152342e9cf75f9a0213d87e9aa14fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gradient node of the op node This function generates the backward graph of the node.  <a href="#a6152342e9cf75f9a0213d87e9aa14fa2">More...</a><br /></td></tr>
<tr class="separator:a6152342e9cf75f9a0213d87e9aa14fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d810b44f7ecee5b7bad99d5c970ada3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a3d810b44f7ecee5b7bad99d5c970ada3">FSetInputVarAttrOnCompose</a> = std::function&lt; void(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs, <a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">NodePtr</a> var, const int index)&gt;</td></tr>
<tr class="memdesc:a3d810b44f7ecee5b7bad99d5c970ada3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the attributes of input variable. Usually used for setting initialization or weight decay.  <a href="#a3d810b44f7ecee5b7bad99d5c970ada3">More...</a><br /></td></tr>
<tr class="separator:a3d810b44f7ecee5b7bad99d5c970ada3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df0ffb0a105133c97d5fbc9d782c618"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a2df0ffb0a105133c97d5fbc9d782c618">FCorrectLayout</a> = std::function&lt; bool(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs, std::vector&lt; <a class="el" href="classnnvm_1_1Layout.html">Layout</a> &gt; *ilayouts, const std::vector&lt; <a class="el" href="classnnvm_1_1Layout.html">Layout</a> &gt; *last_ilayouts, std::vector&lt; <a class="el" href="classnnvm_1_1Layout.html">Layout</a> &gt; *olayouts)&gt;</td></tr>
<tr class="memdesc:a2df0ffb0a105133c97d5fbc9d782c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer &amp; correct function of node layout. See <code><a class="el" href="classnnvm_1_1Layout.html">Layout</a></code> for layout convention.  <a href="#a2df0ffb0a105133c97d5fbc9d782c618">More...</a><br /></td></tr>
<tr class="separator:a2df0ffb0a105133c97d5fbc9d782c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d636002e2d607e2692cd0899c416b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#af0d636002e2d607e2692cd0899c416b6">FInputGraph</a> = std::function&lt; std::vector&lt; uint32_t &gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a> &amp;attrs)&gt;</td></tr>
<tr class="memdesc:af0d636002e2d607e2692cd0899c416b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of inputs that represent graphs instead of data. Normally, input symbols are considered as data to the operator. However, control flow operators and high-order functions need to interpret symbols as graphs.  <a href="#af0d636002e2d607e2692cd0899c416b6">More...</a><br /></td></tr>
<tr class="separator:af0d636002e2d607e2692cd0899c416b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b287a170f9c63ddccb53a7f93bb8ed"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; <a class="el" href="classnnvm_1_1Graph.html">Graph</a>(<a class="el" href="classnnvm_1_1Graph.html">Graph</a> src)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#ac2b287a170f9c63ddccb53a7f93bb8ed">PassFunction</a></td></tr>
<tr class="memdesc:ac2b287a170f9c63ddccb53a7f93bb8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PassFunction is an "Operator on Graph". It takes a source graph and return a graph that may or may not be the same as the input one.  <a href="#ac2b287a170f9c63ddccb53a7f93bb8ed">More...</a><br /></td></tr>
<tr class="separator:ac2b287a170f9c63ddccb53a7f93bb8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1742f4071051bd6949ef5f4f007a6e9a"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a1742f4071051bd6949ef5f4f007a6e9a">dim_t</a></td></tr>
<tr class="memdesc:a1742f4071051bd6949ef5f4f007a6e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type to store dim size  <a href="#a1742f4071051bd6949ef5f4f007a6e9a">More...</a><br /></td></tr>
<tr class="separator:a1742f4071051bd6949ef5f4f007a6e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b06865bedddb2bab9903e448120658c"><td class="memTemplParams" colspan="2">template&lt;typename FVisit &gt; </td></tr>
<tr class="memitem:a6b06865bedddb2bab9903e448120658c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a6b06865bedddb2bab9903e448120658c">DFSVisit</a> (const std::vector&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> &gt; &amp;heads, FVisit fvisit)</td></tr>
<tr class="memdesc:a6b06865bedddb2bab9903e448120658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a Post Order DFS visit to each node in the graph. This order is deterministic and is also topoligical sorted.  <a href="#a6b06865bedddb2bab9903e448120658c">More...</a><br /></td></tr>
<tr class="separator:a6b06865bedddb2bab9903e448120658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f3e607ea360d951389b4b9b83eb7fe"><td class="memTemplParams" colspan="2">template&lt;typename GNode , typename HashType , typename FVisit , typename HashFunc , typename InDegree , typename GetInput &gt; </td></tr>
<tr class="memitem:a24f3e607ea360d951389b4b9b83eb7fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a24f3e607ea360d951389b4b9b83eb7fe">PostOrderDFSVisit</a> (const std::vector&lt; GNode &gt; &amp;heads, FVisit fvisit, HashFunc hash, InDegree indegree, GetInput getinput)</td></tr>
<tr class="separator:a24f3e607ea360d951389b4b9b83eb7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507b0c46e364695405ca24b6010ed6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a507b0c46e364695405ca24b6010ed6b9">MakeNode</a> (const char *op_name, std::string node_name, std::vector&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> &gt; inputs, std::unordered_map&lt; std::string, std::string &gt; attrs=std::unordered_map&lt; std::string, std::string &gt;())</td></tr>
<tr class="memdesc:a507b0c46e364695405ca24b6010ed6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick utilities make node.  <a href="#a507b0c46e364695405ca24b6010ed6b9">More...</a><br /></td></tr>
<tr class="separator:a507b0c46e364695405ca24b6010ed6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b92fb36f36675e96255310f3450662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnnvm_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a36b92fb36f36675e96255310f3450662">ApplyPasses</a> (<a class="el" href="classnnvm_1_1Graph.html">Graph</a> src, const std::vector&lt; std::string &gt; &amp;passes)</td></tr>
<tr class="memdesc:a36b92fb36f36675e96255310f3450662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a series of pass transformations on the input graph.  <a href="#a36b92fb36f36675e96255310f3450662">More...</a><br /></td></tr>
<tr class="separator:a36b92fb36f36675e96255310f3450662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e352fbb58722c23de790c9cfafdfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnnvm_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a> (<a class="el" href="classnnvm_1_1Graph.html">Graph</a> src, const std::string &amp;pass)</td></tr>
<tr class="memdesc:af9e352fbb58722c23de790c9cfafdfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one pass to the graph.  <a href="#af9e352fbb58722c23de790c9cfafdfd7">More...</a><br /></td></tr>
<tr class="separator:af9e352fbb58722c23de790c9cfafdfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3e89603b8701b127dd3671090196fd"><td class="memTemplParams" colspan="2">template&lt;typename SrcIter , typename DstIter &gt; </td></tr>
<tr class="memitem:aeb3e89603b8701b127dd3671090196fd"><td class="memTemplItemLeft" align="right" valign="top">DstIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacennvm.html#aeb3e89603b8701b127dd3671090196fd">ShapeTypeCast</a> (const SrcIter begin, const SrcIter end, DstIter dst_begin)</td></tr>
<tr class="memdesc:aeb3e89603b8701b127dd3671090196fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to cast type of container elements  <a href="#aeb3e89603b8701b127dd3671090196fd">More...</a><br /></td></tr>
<tr class="separator:aeb3e89603b8701b127dd3671090196fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6163e61f55b40ecdc68b431b959f0a"><td class="memTemplParams" colspan="2">template&lt;typename SrcIter &gt; </td></tr>
<tr class="memitem:a5f6163e61f55b40ecdc68b431b959f0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnnvm_1_1TShape.html">TShape</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacennvm.html#a5f6163e61f55b40ecdc68b431b959f0a">ShapeTypeCast</a> (const SrcIter begin, const SrcIter end)</td></tr>
<tr class="memdesc:a5f6163e61f55b40ecdc68b431b959f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to transform a container to <a class="el" href="classnnvm_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">TShape</a> with type cast  <a href="#a5f6163e61f55b40ecdc68b431b959f0a">More...</a><br /></td></tr>
<tr class="separator:a5f6163e61f55b40ecdc68b431b959f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a52d908d5e1bfdbd544f1b6d2c99682cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a52d908d5e1bfdbd544f1b6d2c99682cc">nnvm::DeviceAssignMap</a> = typedef std::unordered_map&lt;std::string, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of device of each operator in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["device_assign_map"], needed by Pass "PlaceDevice" -1 means unknown device </dd></dl>

</div>
</div>
<a class="anchor" id="a94df41af9f53acd922091f62baab0f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a94df41af9f53acd922091f62baab0f81">nnvm::DeviceVector</a> = typedef std::vector&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of device of each operator in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["device"], provided by Pass "PlaceDevice"</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;PlaceDevice&quot;</span>);</div><div class="line"><span class="keyword">const</span> &amp;device = g.GetAttr&lt;<a class="code" href="namespacennvm.html#a94df41af9f53acd922091f62baab0f81">DeviceVector</a>&gt;(<span class="stringliteral">&quot;device&quot;</span>);</div><div class="line"><span class="comment">// get device by node_id</span></div><div class="line"><span class="keywordtype">int</span> device_type = device[g.indexed_graph().node_id(my_node)];</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1742f4071051bd6949ef5f4f007a6e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="namespacennvm.html#a1742f4071051bd6949ef5f4f007a6e9a">nnvm::dim_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data type to store dim size </p>

</div>
</div>
<a class="anchor" id="af3047555e6bce725a8abba02b4155de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#af3047555e6bce725a8abba02b4155de9">nnvm::DTypeVector</a> = typedef std::vector&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of type of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["dtype"], provided by Pass "InferType"</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;InferType&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacennvm.html#af3047555e6bce725a8abba02b4155de9">DTypeVector</a>&amp; types = g.GetAttr&lt;<a class="code" href="namespacennvm.html#af3047555e6bce725a8abba02b4155de9">DTypeVector</a>&gt;(<span class="stringliteral">&quot;dtype&quot;</span>);</div><div class="line"><span class="comment">// get type by entry id</span></div><div class="line"><span class="keywordtype">int</span> entry_type = dtypes[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacennvm.html#a6539f5c3067c4c3cd7dbbdd6b6a6f165" title="Type inference function. Update the type given the known type information. ">FInferType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2df0ffb0a105133c97d5fbc9d782c618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a2df0ffb0a105133c97d5fbc9d782c618">nnvm::FCorrectLayout</a> = typedef std::function&lt;bool( const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs, std::vector&lt;<a class="el" href="classnnvm_1_1Layout.html">Layout</a>&gt; *ilayouts, const std::vector&lt;<a class="el" href="classnnvm_1_1Layout.html">Layout</a>&gt; *last_ilayouts, std::vector&lt;<a class="el" href="classnnvm_1_1Layout.html">Layout</a>&gt; *olayouts)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer &amp; correct function of node layout. See <code><a class="el" href="classnnvm_1_1Layout.html">Layout</a></code> for layout convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the node. </td></tr>
    <tr><td class="paramname">ilayouts</td><td>Given the input layouts produced by ancestor nodes, it should be filled by layouts that the node requests. If the requested layout is different from what ancestor produces, a <b>layout_transform</b> operator will be inserted automatically. </td></tr>
    <tr><td class="paramname">last_ilayouts</td><td>The input layouts requested by the node at the last infer pass (if any). This can be useful when an operator wants to keep the input layout the same as the original one. For example, after the pass of AlterOpLayout, transpose(input, axis=[1, 2, 3, 0]) may receive an input of NCHW16c layout, with which it cannot calculate with axis=[1, 2, 3, 0]. Last input layouts allow it to know what the layout it originally inferred, i.e., the layout in the imported model. </td></tr>
    <tr><td class="paramname">olayouts</td><td>Inferred output layouts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success flag. </dd></dl>

</div>
</div>
<a class="anchor" id="ac04d7b8e69e50b67769cb496c15b5fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#ac04d7b8e69e50b67769cb496c15b5fce">nnvm::FGetAttrDict</a> = typedef std::function&lt; std::unordered_map&lt;std::string, std::string&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get attribute dictionary from node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute dict. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FUpdateAttrDict" </dd></dl>

</div>
</div>
<a class="anchor" id="a6152342e9cf75f9a0213d87e9aa14fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a6152342e9cf75f9a0213d87e9aa14fa2">nnvm::FGradient</a> = typedef std::function&lt;std::vector&lt;<a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a>&gt;( const <a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">NodePtr</a>&amp; nodeptr, const std::vector&lt;<a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a>&gt;&amp; out_grads)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the gradient node of the op node This function generates the backward graph of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeptr</td><td>The node to take gradient </td></tr>
    <tr><td class="paramname">out_grads</td><td>Gradient of current node's outputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gradients of the inputs</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FGradient" </dd></dl>

</div>
</div>
<a class="anchor" id="ab951c7d30fcc4f17ffddbfd082d24792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#ab951c7d30fcc4f17ffddbfd082d24792">nnvm::FIgnoreInputs</a> = typedef std::function&lt; std::vector&lt;uint32_t&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of inputs in the op whose content are actually not used by the operator These are dummy input that can be used for example in zeros_like, ones_like. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list input index that are not used by the operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FIgnoreInputs". </dd></dl>

</div>
</div>
<a class="anchor" id="a39a12a38eb8f3ac625170e8be2099d57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">nnvm::FInferNodeEntryAttr</a> = typedef std::function&lt;bool (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs, std::vector&lt;AttrType&gt; *in_attrs, std::vector&lt;AttrType&gt; *out_attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inference function of certain type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AttrType</td><td>The type of the attribute to be infered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether all attributes are inferred. </dd></dl>

</div>
</div>
<a class="anchor" id="ae80cd6cc2432e36350ad84335d5e5308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#ae80cd6cc2432e36350ad84335d5e5308">nnvm::FInferShape</a> = typedef <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">FInferNodeEntryAttr</a>&lt;<a class="el" href="classnnvm_1_1TShape.html">TShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shape inference function. Update the shapes given the input shape information. <a class="el" href="classnnvm_1_1Tuple.html#ab0525b3d997b77dfd5c6b35299b250f6">TShape.ndim()</a> == 0 means the shape is still unknown. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FInferShape", by default do not update any shapes.</dd></dl>
<p>FInferShape is needed by shape inference </p>

</div>
</div>
<a class="anchor" id="a6539f5c3067c4c3cd7dbbdd6b6a6f165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a6539f5c3067c4c3cd7dbbdd6b6a6f165">nnvm::FInferType</a> = typedef <a class="el" href="namespacennvm.html#a39a12a38eb8f3ac625170e8be2099d57">FInferNodeEntryAttr</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type inference function. Update the type given the known type information. </p>
<dl class="section note"><dt>Note</dt><dd>Register under "FInferType", by default set all the output types to 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a39ef67828f4ddb6c7aea2e3b1b685d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a39ef67828f4ddb6c7aea2e3b1b685d90">nnvm::FInplaceIdentity</a> = typedef std::function&lt;std::vector&lt;bool&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get if the inplace option is an identity This function enables inplace optimization even when input reference count is greater than one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of bool indicating whether corresponding pair from FInplaceOption is an identity</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FInplaceIdentity", by default no identities. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d4bdafc4a28981d4d9b5fc8207fc04c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a7d4bdafc4a28981d4d9b5fc8207fc04c">nnvm::FInplaceOption</a> = typedef std::function&lt; std::vector&lt;std::pair&lt;int, int&gt; &gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get possible inplace options. This function enables optimization to reuse memory of inputs in output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of pair of that maps input-&gt;output, indicating possible in place operations.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FInplaceOption", by default no inplace can happen. </dd></dl>

</div>
</div>
<a class="anchor" id="af0d636002e2d607e2692cd0899c416b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#af0d636002e2d607e2692cd0899c416b6">nnvm::FInputGraph</a> = typedef std::function&lt;std::vector&lt;uint32_t&gt;(const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of inputs that represent graphs instead of data. Normally, input symbols are considered as data to the operator. However, control flow operators and high-order functions need to interpret symbols as graphs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of input index that are interpreted as symbols by the operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FInputGraph". </dd></dl>

</div>
</div>
<a class="anchor" id="a5b811999ef6b9e8a789e2c359642738a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a5b811999ef6b9e8a789e2c359642738a">nnvm::FListInputNames</a> = typedef std::function&lt;std::vector&lt;std::string&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of input arguments names of each operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of inputs </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FListInputNames", default return {"data"}.</dd></dl>
<p>FListInputNames enables automatic variable creation for missing arguments. </p>

</div>
</div>
<a class="anchor" id="af4188d4a9d1daecdecb9b0136b9ff3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#af4188d4a9d1daecdecb9b0136b9ff3e7">nnvm::FListOutputNames</a> = typedef std::function&lt;std::vector&lt;std::string&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of output arguments names of each operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of inputs </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FListOutputNames", default return {"outputs"}.</dd></dl>
<p>FListOutputNames customized naming for operator outputs. </p>

</div>
</div>
<a class="anchor" id="a12f43958d8171a8f2ab11880192b7125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a12f43958d8171a8f2ab11880192b7125">nnvm::FMutateInputs</a> = typedef std::function&lt;std::vector&lt;uint32_t&gt; (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether operator will mutate k-th input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of input indices it mutates.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FMutateInputs", default return false FMutateInputs enables mutation order handling correctly. </dd></dl>

</div>
</div>
<a class="anchor" id="a475e6d8a1f6f0f63977e0b2e2a8b0ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a475e6d8a1f6f0f63977e0b2e2a8b0ef7">nnvm::FNumVisibleOutputs</a> = typedef std::function&lt;uint32_t (const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of visible outputs by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Register under "FNumVisibleOutputs", default not registered. This can be used to hide certain output from the user, but the additional outputs can be used to pass information from forward to gradient pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d810b44f7ecee5b7bad99d5c970ada3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a3d810b44f7ecee5b7bad99d5c970ada3">nnvm::FSetInputVarAttrOnCompose</a> = typedef std::function&lt;void( const <a class="el" href="structnnvm_1_1NodeAttrs.html">NodeAttrs</a>&amp; attrs, <a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">NodePtr</a> var, const int index)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the attributes of input variable. Usually used for setting initialization or weight decay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attributes of this node. </td></tr>
    <tr><td class="paramname">var</td><td>the input variable </td></tr>
    <tr><td class="paramname">index</td><td>index of var in all inputs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dd0c9e8b1f22efb36a05956ec22af55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a2dd0c9e8b1f22efb36a05956ec22af55">nnvm::JSONString</a> = typedef std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of JSON serializer. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under ret.attrs["json"], provided by Pass "SaveJSON"</dd></dl>
<div class="fragment"><div class="line">Graph ret = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;SaveJSON&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacennvm.html#a2dd0c9e8b1f22efb36a05956ec22af55">JSONString</a>&amp; json = ret.GetAttr&lt;<a class="code" href="namespacennvm.html#a2dd0c9e8b1f22efb36a05956ec22af55">JSONString</a>&gt;(<span class="stringliteral">&quot;shape&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a64589af0262bef2f459d1570628b85da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a64589af0262bef2f459d1570628b85da">nnvm::LayoutVector</a> = typedef std::vector&lt;<a class="el" href="classnnvm_1_1Layout.html">Layout</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of layout of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["layout"], provided by Pass "InferType"</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;LayoutTransform&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacennvm.html#a64589af0262bef2f459d1570628b85da">LayoutVector</a>&amp; layouts = g.GetAttr&lt;<a class="code" href="namespacennvm.html#a64589af0262bef2f459d1570628b85da">LayoutVector</a>&gt;(<span class="stringliteral">&quot;layout&quot;</span>);</div><div class="line"><span class="comment">// get layout by entry id</span></div><div class="line"><span class="keywordtype">int</span> entry_layout = layouts[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacennvm.html#a2df0ffb0a105133c97d5fbc9d782c618" title="Infer &amp; correct function of node layout. See Layout for layout convention. ">FCorrectLayout</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a90679a7e880dbf3f009d8d5bfc99c8d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a90679a7e880dbf3f009d8d5bfc99c8d4">nnvm::NodeEntryMap</a> = typedef std::unordered_map&lt;<a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a>, ValueType, <a class="el" href="structnnvm_1_1NodeEntryHash.html">NodeEntryHash</a>, <a class="el" href="structnnvm_1_1NodeEntryEqual.html">NodeEntryEqual</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>use <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> as key in unordered_map </p>

</div>
</div>
<a class="anchor" id="a4259d4f89d9f0feb94111a1c8cb5a1ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a4259d4f89d9f0feb94111a1c8cb5a1ae">nnvm::NodePtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classnnvm_1_1Node.html">Node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>we always used NodePtr for a reference pointer to the node, so this alias can be changed in case. </p>
<p>By default, NodePtr is a std::shared_ptr of node </p>

</div>
</div>
<a class="anchor" id="ac2b287a170f9c63ddccb53a7f93bb8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;<a class="el" href="classnnvm_1_1Graph.html">Graph</a> (<a class="el" href="classnnvm_1_1Graph.html">Graph</a> src)&gt; <a class="el" href="namespacennvm.html#ac2b287a170f9c63ddccb53a7f93bb8ed">nnvm::PassFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A PassFunction is an "Operator on Graph". It takes a source graph and return a graph that may or may not be the same as the input one. </p>
<p>A pass function can either change the graph structure (thus, generating a new <a class="el" href="classnnvm_1_1Graph.html" title="Symbolic computation graph. This is the intermediate representation for optimization pass...">Graph</a>), or add new attributes to the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The graph to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a77a000cfbb76bfc17042b49ef30fe36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#a77a000cfbb76bfc17042b49ef30fe36f">nnvm::ShapeVector</a> = typedef std::vector&lt;<a class="el" href="classnnvm_1_1TShape.html">TShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of shape of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["shape"], provided by Pass "InferShape"</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;InferShape&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacennvm.html#a77a000cfbb76bfc17042b49ef30fe36f">ShapeVector</a>&amp; shapes = g.GetAttr&lt;<a class="code" href="namespacennvm.html#a77a000cfbb76bfc17042b49ef30fe36f">ShapeVector</a>&gt;(<span class="stringliteral">&quot;shape&quot;</span>);</div><div class="line"><span class="comment">// get shape by entry id</span></div><div class="line">TShape entry_shape = shapes[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacennvm.html#ae80cd6cc2432e36350ad84335d5e5308" title="Shape inference function. Update the shapes given the input shape information. TShape.ndim() == 0 means the shape is still unknown. ">FInferShape</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3ab8a09faa366b06b78d31c65f620af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#ad3ab8a09faa366b06b78d31c65f620af">nnvm::StorageVector</a> = typedef std::vector&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result holder of storage id of each <a class="el" href="structnnvm_1_1NodeEntry.html" title="an entry that represents output data from a node ">NodeEntry</a> in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Stored under graph.attrs["storage"], provided by Pass "PlanMemory" Storage id is a continuous integer. If the storage id is -1 then the storage is not assigned.</dd></dl>
<div class="fragment"><div class="line">Graph g = <a class="code" href="namespacennvm.html#af9e352fbb58722c23de790c9cfafdfd7">ApplyPass</a>(src_graph, <span class="stringliteral">&quot;PlanMemory&quot;</span>);</div><div class="line"><span class="keyword">const</span> &amp;storage = g.GetAttr&lt;<a class="code" href="namespacennvm.html#ad3ab8a09faa366b06b78d31c65f620af">StorageVector</a>&gt;(<span class="stringliteral">&quot;storage&quot;</span>);</div><div class="line"><span class="comment">// get storage id by entry</span></div><div class="line"><span class="keywordtype">int</span> storage_id = storage[g.indexed_graph().entry_id(my_entry)];</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac317e6034c26f9cb453e91cd38e35df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacennvm.html#ac317e6034c26f9cb453e91cd38e35df9">nnvm::TIsBackward</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this op is an explicit backward operator, If TIsBackward is true: </p>
<ul>
<li>The first control_deps of the node points to the corresponding forward operator.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Register under "TIsBackward" This enables easier shape/type inference for backward operators. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af9e352fbb58722c23de790c9cfafdfd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnnvm_1_1Graph.html">Graph</a> nnvm::ApplyPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnnvm_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply one pass to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The graph to be transformed. </td></tr>
    <tr><td class="paramname">pass</td><td>The name of pass to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a36b92fb36f36675e96255310f3450662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnnvm_1_1Graph.html">Graph</a> nnvm::ApplyPasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnnvm_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>passes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a series of pass transformations on the input graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The graph to be transformed. </td></tr>
    <tr><td class="paramname">passes</td><td>A list of pass names to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed graph </dd></dl>

</div>
</div>
<a class="anchor" id="a6b06865bedddb2bab9903e448120658c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FVisit &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nnvm::DFSVisit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>heads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVisit&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform a Post Order DFS visit to each node in the graph. This order is deterministic and is also topoligical sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heads</td><td>The heads in the graph. </td></tr>
    <tr><td class="paramname">fvisit</td><td>a function of type std::function&lt;void(const std::shared_ptr&lt;Node&gt;&amp;)&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FVisit</td><td>The function type to perform the visit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a507b0c46e364695405ca24b6010ed6b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> nnvm::MakeNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structnnvm_1_1NodeEntry.html">NodeEntry</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt;&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>std::unordered_map&lt;std::string,&#160;std::string&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quick utilities make node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_name</td><td>The name of operator </td></tr>
    <tr><td class="paramname">node_name</td><td>The name of the node </td></tr>
    <tr><td class="paramname">inputs</td><td>The input entries </td></tr>
    <tr><td class="paramname">attrs</td><td>The attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created node entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a24f3e607ea360d951389b4b9b83eb7fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GNode , typename HashType , typename FVisit , typename HashFunc , typename InDegree , typename GetInput &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nnvm::PostOrderDFSVisit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; GNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>heads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVisit&#160;</td>
          <td class="paramname"><em>fvisit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashFunc&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InDegree&#160;</td>
          <td class="paramname"><em>indegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetInput&#160;</td>
          <td class="paramname"><em>getinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb3e89603b8701b127dd3671090196fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcIter , typename DstIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DstIter nnvm::ShapeTypeCast </td>
          <td>(</td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DstIter&#160;</td>
          <td class="paramname"><em>dst_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to cast type of container elements </p>

</div>
</div>
<a class="anchor" id="a5f6163e61f55b40ecdc68b431b959f0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnnvm_1_1TShape.html">TShape</a> nnvm::ShapeTypeCast </td>
          <td>(</td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SrcIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to transform a container to <a class="el" href="classnnvm_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor. ">TShape</a> with type cast </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 6 2019 11:14:40 for tvm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
