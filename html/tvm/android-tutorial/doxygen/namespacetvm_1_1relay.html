<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::relay Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay.html">relay</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relay Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Relay: a high level functional IR for TVM.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1pass"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1pass.html">pass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ArangeAttrs.html">ArangeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in arange operators.  <a href="structtvm_1_1relay_1_1ArangeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool2DAttrs.html">AvgPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1BaseTensorType.html">BaseTensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1BaseTensorTypeNode.html">BaseTensorTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base of all <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> types This container can hold <a class="el" href="classtvm_1_1relay_1_1TensorType.html">TensorType</a> or GenericTensorType.  <a href="classtvm_1_1relay_1_1BaseTensorTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BatchNormAttrs.html">BatchNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in batch_norm operator.  <a href="structtvm_1_1relay_1_1BatchNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BiasAddAttrs.html">BiasAddAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a 1D <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> to an axis of a data.  <a href="structtvm_1_1relay_1_1BiasAddAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> container.  <a href="classtvm_1_1relay_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CastAttrs.html">CastAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type cast  <a href="structtvm_1_1relay_1_1CastAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ClauseNode.html">ClauseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> container node.  <a href="classtvm_1_1relay_1_1ClauseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ClipAttrs.html">ClipAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for Clip operator.  <a href="structtvm_1_1relay_1_1ClipAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ClosureNode.html">ClosureNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container type of Closures.  <a href="classtvm_1_1relay_1_1ClosureNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConcatenateAttrs.html">ConcatenateAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in concatenate operators.  <a href="structtvm_1_1relay_1_1ConcatenateAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstantNode.html">ConstantNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a> tensor type.  <a href="classtvm_1_1relay_1_1ConstantNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Constructor.html">Constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstructorNode.html">ConstructorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Constructor.html">Constructor</a> container node.  <a href="classtvm_1_1relay_1_1ConstructorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConstructorValueNode.html">ConstructorValueNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DAttrs.html">Conv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators.  <a href="structtvm_1_1relay_1_1Conv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DTransposeAttrs.html">Conv2DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transposed convolution operator.  <a href="structtvm_1_1relay_1_1Conv2DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradAttrs.html">Conv2DWinogradAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators with winograd algorithm.  <a href="structtvm_1_1relay_1_1Conv2DWinogradAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs.html">Conv2DWinogradNNPACKWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in winograd weight transformation operators.  <a href="structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradWeightTransformAttrs.html">Conv2DWinogradWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in winograd weight transformation operators.  <a href="structtvm_1_1relay_1_1Conv2DWinogradWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DebugAttrs.html">DebugAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the debug operators.  <a href="structtvm_1_1relay_1_1DebugAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DeformableConv2DAttrs.html">DeformableConv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for DeformableConv2D operator.  <a href="structtvm_1_1relay_1_1DeformableConv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DenseAttrs.html">DenseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for dense operator.  <a href="structtvm_1_1relay_1_1DenseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DeviceCopyAttrs.html">DeviceCopyAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the device copy operators.  <a href="structtvm_1_1relay_1_1DeviceCopyAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DropoutAttrs.html">DropoutAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dropout operator.  <a href="structtvm_1_1relay_1_1DropoutAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Error.html">Error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ErrorReporter.html">ErrorReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction around how errors are stored and reported. Designed to be opaque to users, so we can support a robust and simpler error reporting mode, as well as a more complex mode.  <a href="classtvm_1_1relay_1_1ErrorReporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ExpandDimsAttrs.html">ExpandDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in expand_dims operators.  <a href="structtvm_1_1relay_1_1ExpandDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>.  <a href="classtvm_1_1relay_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const Expr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> which functionally updates the AST.  <a href="classtvm_1_1relay_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprNode.html">ExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of the Relay expression hiearchy.  <a href="classtvm_1_1relay_1_1ExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relay_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FunctionNode.html">FunctionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> container.  <a href="classtvm_1_1relay_1_1FunctionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FuncType.html">FuncType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FuncTypeNode.html">FuncTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> type in Relay.  <a href="classtvm_1_1relay_1_1FuncTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1GenericOpMap.html">GenericOpMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic map to store additional information of <a class="el" href="classtvm_1_1relay_1_1Op.html" title="Operator reference class. ">Op</a>.  <a href="classtvm_1_1relay_1_1GenericOpMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GetValidCountsAttrs.html">GetValidCountsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in get_valid_counts operator.  <a href="structtvm_1_1relay_1_1GetValidCountsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GlobalPool2DAttrs.html">GlobalPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for global pool operator.  <a href="structtvm_1_1relay_1_1GlobalPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1GlobalTypeVar.html">GlobalTypeVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1GlobalTypeVarNode.html">GlobalTypeVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1GlobalTypeVar.html">GlobalTypeVar</a> container node.  <a href="classtvm_1_1relay_1_1GlobalTypeVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1GlobalVar.html">GlobalVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1GlobalVarNode.html">GlobalVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A GlobalId from the node's current type to target type.  <a href="classtvm_1_1relay_1_1GlobalVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IdNode.html">IdNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier of variables.  <a href="classtvm_1_1relay_1_1IdNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1If.html">If</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IfNode.html">IfNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of <a class="el" href="classtvm_1_1relay_1_1If.html">If</a>  <a href="classtvm_1_1relay_1_1IfNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IncompleteType.html">IncompleteType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IncompleteTypeNode.html">IncompleteTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1IncompleteType.html">IncompleteType</a> container node.  <a href="classtvm_1_1relay_1_1IncompleteTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1InitOpAttrs.html">InitOpAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes that specify a tensor.  <a href="structtvm_1_1relay_1_1InitOpAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1L2NormalizeAttrs.html">L2NormalizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for L2Normalize operator.  <a href="structtvm_1_1relay_1_1L2NormalizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LayoutTransformAttrs.html">LayoutTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for LayoutTransform operator.  <a href="structtvm_1_1relay_1_1LayoutTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LeakyReluAttrs.html">LeakyReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for leaky relu operator.  <a href="structtvm_1_1relay_1_1LeakyReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding of a sub-network.  <a href="classtvm_1_1relay_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LRNAttrs.html">LRNAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for LRN operator.  <a href="structtvm_1_1relay_1_1LRNAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1MatchNode.html">MatchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> container node.  <a href="classtvm_1_1relay_1_1MatchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool2DAttrs.html">MaxPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ModuleNode.html">ModuleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global environment of Relay programs.  <a href="classtvm_1_1relay_1_1ModuleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MultiBoxPriorAttrs.html">MultiBoxPriorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in multibox_prior operators.  <a href="structtvm_1_1relay_1_1MultiBoxPriorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MultiBoxTransformLocAttrs.html">MultiBoxTransformLocAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NonMaximumSuppressionAttrs.html">NonMaximumSuppressionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in non_maximum_suppression operator.  <a href="structtvm_1_1relay_1_1NonMaximumSuppressionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1OnDeviceAttrs.html">OnDeviceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the device annotation operators.  <a href="structtvm_1_1relay_1_1OnDeviceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator reference class.  <a href="classtvm_1_1relay_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpMap.html">OpMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map&lt;Op,ValueType&gt; used to store meta-information about <a class="el" href="classtvm_1_1relay_1_1Op.html" title="Operator reference class. ">Op</a>.  <a href="classtvm_1_1relay_1_1OpMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpNode.html">OpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node container of operator structure.  <a href="classtvm_1_1relay_1_1OpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpRegistry.html">OpRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure to register operators.  <a href="classtvm_1_1relay_1_1OpRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1PadAttrs.html">PadAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the padding operator.  <a href="structtvm_1_1relay_1_1PadAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> is the base type for an ADT match pattern in Relay.  <a href="classtvm_1_1relay_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternConstructor.html">PatternConstructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternConstructorNode.html">PatternConstructorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternConstructorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternFunctor.html">PatternFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor on ADT patterns that dispatches on its first argument. You can use this as a more powerful visitor, since it allows you to define the types of further arguments to VisitPattern.  <a href="classtvm_1_1relay_1_1PatternFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternFunctor_3_01R_07const_01Pattern_01_6n_00_01Args_8_8_8_08_4.html">PatternFunctor&lt; R(const Pattern &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternMutator.html">PatternMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> which functionally updates the AST.  <a href="classtvm_1_1relay_1_1PatternMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternNode.html">PatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for declaring relay pattern.  <a href="classtvm_1_1relay_1_1PatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVarNode.html">PatternVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVisitor.html">PatternVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1PatternFunctor.html" title="A dynamical functor on ADT patterns that dispatches on its first argument. You can use this as a more...">PatternFunctor</a>.  <a href="classtvm_1_1relay_1_1PatternVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternWildcard.html">PatternWildcard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternWildcardNode.html">PatternWildcardNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternWildcard.html">PatternWildcard</a> container node.  <a href="classtvm_1_1relay_1_1PatternWildcardNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1PReluAttrs.html">PReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for prelu operator.  <a href="structtvm_1_1relay_1_1PReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ProposalAttrs.html">ProposalAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in proposal operators.  <a href="structtvm_1_1relay_1_1ProposalAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefCreateNode.html">RefCreateNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefReadNode.html">RefReadNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefType.html">RefType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefTypeNode.html">RefTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference <a class="el" href="classtvm_1_1relay_1_1Type.html" title="Type is the base type of relay type hiearchy. ">Type</a> in relay.  <a href="classtvm_1_1relay_1_1RefTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RefValueNode.html">RefValueNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefWriteNode.html">RefWriteNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RelayErrorStream.html">RelayErrorStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around std::stringstream.  <a href="structtvm_1_1relay_1_1RelayErrorStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RelayNode.html">RelayNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base node container of all relay structures.  <a href="classtvm_1_1relay_1_1RelayNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RepeatAttrs.html">RepeatAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in repeat operators.  <a href="structtvm_1_1relay_1_1RepeatAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReshapeAttrs.html">ReshapeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reshape operators.  <a href="structtvm_1_1relay_1_1ReshapeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ResizeAttrs.html">ResizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize operator.  <a href="structtvm_1_1relay_1_1ResizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReverseAttrs.html">ReverseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reverse operators.  <a href="structtvm_1_1relay_1_1ReverseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ROIAlignAttrs.html">ROIAlignAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in roi_align operators.  <a href="structtvm_1_1relay_1_1ROIAlignAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ROIPoolAttrs.html">ROIPoolAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in roi_pool operators.  <a href="structtvm_1_1relay_1_1ROIPoolAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ShapeOfAttrs.html">ShapeOfAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for ShapeOf operator.  <a href="structtvm_1_1relay_1_1ShapeOfAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SliceLikeAttrs.html">SliceLikeAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SoftmaxAttrs.html">SoftmaxAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softmax operators.  <a href="structtvm_1_1relay_1_1SoftmaxAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1SourceName.html">SourceName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source name of a file span.  <a href="classtvm_1_1relay_1_1SourceName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1SourceNameNode.html">SourceNameNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of a source fragment.  <a href="classtvm_1_1relay_1_1SourceNameNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Span.html">Span</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1SpanNode.html">SpanNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores locations in frontend source that generated a node.  <a href="classtvm_1_1relay_1_1SpanNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SplitAttrs.html">SplitAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SqueezeAttrs.html">SqueezeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in squeeze operators.  <a href="structtvm_1_1relay_1_1SqueezeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StackAttrs.html">StackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in stack operators.  <a href="structtvm_1_1relay_1_1StackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StridedSliceAttrs.html">StridedSliceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for StridedSlice operator.  <a href="structtvm_1_1relay_1_1StridedSliceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StructuralHash.html">StructuralHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashing structure in the style of std::hash.  <a href="structtvm_1_1relay_1_1StructuralHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TakeAttrs.html">TakeAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TempExpr.html">TempExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TempExprNode.html">TempExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of the temporary expression.  <a href="classtvm_1_1relay_1_1TempExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TensorType.html">TensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TensorTypeNode.html">TensorTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TensorType.html">TensorType</a> container node.  <a href="classtvm_1_1relay_1_1TensorTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TensorValueNode.html">TensorValueNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor value container, wrapping an NDArray.  <a href="structtvm_1_1relay_1_1TensorValueNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TileAttrs.html">TileAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in tile operators.  <a href="structtvm_1_1relay_1_1TileAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TransposeAttrs.html">TransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transpose operators.  <a href="structtvm_1_1relay_1_1TransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItemNode.html">TupleGetItemNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleNode.html">TupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> container.  <a href="classtvm_1_1relay_1_1TupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleType.html">TupleType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleTypeNode.html">TupleTypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TupleType.html">TupleType</a> container.  <a href="classtvm_1_1relay_1_1TupleTypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TupleValueNode.html">TupleValueNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> (x, ... y).  <a href="structtvm_1_1relay_1_1TupleValueNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Type.html" title="Type is the base type of relay type hiearchy. ">Type</a> is the base type of relay type hiearchy.  <a href="classtvm_1_1relay_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeCall.html">TypeCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeCallNode.html">TypeCallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TypeCall.html">TypeCall</a> container node.  <a href="classtvm_1_1relay_1_1TypeCallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeConstraint.html">TypeConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeConstraintNode.html">TypeConstraintNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TypeConstraint.html">TypeConstraint</a> container node.  <a href="classtvm_1_1relay_1_1TypeConstraintNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeData.html">TypeData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeDataNode.html">TypeDataNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TypeData.html">TypeData</a> container node.  <a href="classtvm_1_1relay_1_1TypeDataNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeNode.html">TypeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of the Relay type hiearchy.  <a href="classtvm_1_1relay_1_1TypeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeRelation.html">TypeRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeRelationNode.html">TypeRelationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TypeRelation.html">TypeRelation</a> container.  <a href="classtvm_1_1relay_1_1TypeRelationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeReporter.html">TypeReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class of <a class="el" href="classtvm_1_1relay_1_1TypeReporter.html" title="Container class of TypeReporter. ">TypeReporter</a>.  <a href="classtvm_1_1relay_1_1TypeReporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeReporterNode.html">TypeReporterNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reporter that reports back to the type resolution information.  <a href="classtvm_1_1relay_1_1TypeReporterNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TypeVarNode.html">TypeVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> container node.  <a href="classtvm_1_1relay_1_1TypeVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UpSamplingAttrs.html">UpSamplingAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for upsampling operator.  <a href="structtvm_1_1relay_1_1UpSamplingAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ValueNode.html">ValueNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base container type of Relay values.  <a href="classtvm_1_1relay_1_1ValueNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>.  <a href="classtvm_1_1relay_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1YoloReorgAttrs.html">YoloReorgAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in yolo reorg operators.  <a href="structtvm_1_1relay_1_1YoloReorgAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac3c3c5d68fac2fe3bfe69cfbe0305b7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> = tvm::NodeRef</td></tr>
<tr class="memdesc:ac3c3c5d68fac2fe3bfe69cfbe0305b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">We always used NodeRef for referencing nodes.  <a href="#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">More...</a><br /></td></tr>
<tr class="separator:ac3c3c5d68fac2fe3bfe69cfbe0305b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cda5e77824033b608635bc43e31c2e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4cda5e77824033b608635bc43e31c2e5">DataType</a> = ::tvm::Type</td></tr>
<tr class="memdesc:a4cda5e77824033b608635bc43e31c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Content data type.  <a href="#a4cda5e77824033b608635bc43e31c2e5">More...</a><br /></td></tr>
<tr class="separator:a4cda5e77824033b608635bc43e31c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c96f3d3efdabd227ccfe1c60cf396a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac0c96f3d3efdabd227ccfe1c60cf396a">IndexExpr</a> = ::tvm::Expr</td></tr>
<tr class="memdesc:ac0c96f3d3efdabd227ccfe1c60cf396a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression for tensor shape.  <a href="#ac0c96f3d3efdabd227ccfe1c60cf396a">More...</a><br /></td></tr>
<tr class="separator:ac0c96f3d3efdabd227ccfe1c60cf396a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83a9bc802ced1fec6d33f26deeb7f07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac83a9bc802ced1fec6d33f26deeb7f07">NodeHash</a> = ::tvm::NodeHash</td></tr>
<tr class="memdesc:ac83a9bc802ced1fec6d33f26deeb7f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function for nodes. e.g. std::unordered_map&lt;Expr, Value, NodeHash, NodeEqual&gt;  <a href="#ac83a9bc802ced1fec6d33f26deeb7f07">More...</a><br /></td></tr>
<tr class="separator:ac83a9bc802ced1fec6d33f26deeb7f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade06e0c823a00b400c9aeafc2bbf4ae8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ade06e0c823a00b400c9aeafc2bbf4ae8">NodeEqual</a> = ::tvm::NodeEqual</td></tr>
<tr class="memdesc:ade06e0c823a00b400c9aeafc2bbf4ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality check function for nodes.  <a href="#ade06e0c823a00b400c9aeafc2bbf4ae8">More...</a><br /></td></tr>
<tr class="separator:ade06e0c823a00b400c9aeafc2bbf4ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5dab2ddae20ac7564a81ab3a0a9aba76">TOpPattern</a> = int</td></tr>
<tr class="memdesc:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">the operator pattern  <a href="#a5dab2ddae20ac7564a81ab3a0a9aba76">More...</a><br /></td></tr>
<tr class="separator:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afb8a8d4dd43830d4ce7d566abcd1c450">TOpIsStateful</a> = bool</td></tr>
<tr class="memdesc:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether operator is stateful or contain internal state.  <a href="#afb8a8d4dd43830d4ce7d566abcd1c450">More...</a><br /></td></tr>
<tr class="separator:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c835287dfc5ec074ea8431bcebbb17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab4c835287dfc5ec074ea8431bcebbb17">TNonComputational</a> = bool</td></tr>
<tr class="memdesc:ab4c835287dfc5ec074ea8431bcebbb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the operator as non-computational.  <a href="#ab4c835287dfc5ec074ea8431bcebbb17">More...</a><br /></td></tr>
<tr class="separator:ab4c835287dfc5ec074ea8431bcebbb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ff89f08378b7f98416eee0d17f371"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa35ff89f08378b7f98416eee0d17f371">FTVMCompute</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; Array&lt; <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const Array&lt; <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;out_type, const <a class="el" href="classtvm_1_1Target.html">Target</a> &amp;target)&gt;</td></tr>
<tr class="memdesc:aa35ff89f08378b7f98416eee0d17f371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation description interface.  <a href="#aa35ff89f08378b7f98416eee0d17f371">More...</a><br /></td></tr>
<tr class="separator:aa35ff89f08378b7f98416eee0d17f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42de56668e3098b3916f32504df9f99f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a42de56668e3098b3916f32504df9f99f">FTVMSchedule</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Schedule.html">Schedule</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const Array&lt; <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &gt; &amp;outs, const <a class="el" href="classtvm_1_1Target.html">Target</a> &amp;target)&gt;</td></tr>
<tr class="memdesc:a42de56668e3098b3916f32504df9f99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the computation schedule for op whose root is at current op.  <a href="#a42de56668e3098b3916f32504df9f99f">More...</a><br /></td></tr>
<tr class="separator:a42de56668e3098b3916f32504df9f99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016486a28db88f965c28e965f5b9a2e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a016486a28db88f965c28e965f5b9a2e3">FTVMAlterOpLayout</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const Array&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &gt; &amp;args, const Array&lt; <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &gt; &amp;tinfos)&gt;</td></tr>
<tr class="memdesc:a016486a28db88f965c28e965f5b9a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate the layout of operators or replace the operator with other expressions. This function will be invoked in AlterOpLayout pass.  <a href="#a016486a28db88f965c28e965f5b9a2e3">More...</a><br /></td></tr>
<tr class="separator:a016486a28db88f965c28e965f5b9a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6e323b3a8cb6df7969cfcca6fd5165"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4f6e323b3a8cb6df7969cfcca6fd5165">FForwardRewrite</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;ref_call, const Array&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &gt; &amp;new_args, const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:a4f6e323b3a8cb6df7969cfcca6fd5165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward rewriting rule for a specific op.  <a href="#a4f6e323b3a8cb6df7969cfcca6fd5165">More...</a><br /></td></tr>
<tr class="separator:a4f6e323b3a8cb6df7969cfcca6fd5165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abada45a4f21ae750c1caba923f1059"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9abada45a4f21ae750c1caba923f1059">FPrimalGradient</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &gt;(const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;orig_call, const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;output_grad)&gt;</td></tr>
<tr class="memdesc:a9abada45a4f21ae750c1caba923f1059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient for a specific op.  <a href="#a9abada45a4f21ae750c1caba923f1059">More...</a><br /></td></tr>
<tr class="separator:a9abada45a4f21ae750c1caba923f1059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efecf5205823e4e454faeca883da90c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2efecf5205823e4e454faeca883da90c">TypeRelationFn</a> = <a class="el" href="classtvm_1_1TypedEnvFunc.html">TypedEnvFunc</a>&lt; bool(const Array&lt; <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &gt; &amp;args, int num_inputs, const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1relay_1_1TypeReporter.html">TypeReporter</a> &amp;reporter)&gt;</td></tr>
<tr class="memdesc:a2efecf5205823e4e454faeca883da90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined type constraint function.  <a href="#a2efecf5205823e4e454faeca883da90c">More...</a><br /></td></tr>
<tr class="separator:a2efecf5205823e4e454faeca883da90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab5f4d382bf1bee69c3e484ea6c837578"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">OpPatternKind</a> { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a8c63d345994ce14eb197df6ad22de3aa">kElemWise</a> = 0, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a3c016b63ef8869468ab565c862713245">kBroadcast</a> = 1, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a7f703d1ae163ba4e6bef88357a232e00">kInjective</a> = 2, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ad282ac05b650598c3bfb559dc62a0738">kCommReduce</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ab9b265465c486425c2f60cd4057e2ef4">kOutEWiseFusable</a> = 4, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a3cb3cec00829ebd525feba875f2d6ac1">kOpaque</a> = 8
<br />
 }<tr class="memdesc:ab5f4d382bf1bee69c3e484ea6c837578"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator pattern used in graph fusion  <a href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab5f4d382bf1bee69c3e484ea6c837578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae109848a6a58e6d47bee382355d2486b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486b">Kind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486ba3f91eeea0e99e899ac52149dc66ad053">kType</a> = 0, 
<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486ba5a56168a566ff6e421c72a9f7d060c44">kShapeVar</a> = 1, 
<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486baa992fa91a16daaf1380f1636e06963a6">kBaseType</a> = 2, 
<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486babcb7413699d5999795bb570b28d5ea51">kShape</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486bac9f0b6820d2163ddc0da5d57e737d10e">kConstraint</a> = 4, 
<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486ba20abcbd2672c0e96fb5e57a94d341524">kAdtHandle</a> = 5, 
<a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486ba8fd779c0419a9b5631959203403bfd92">kTypeData</a> = 6
<br />
 }<tr class="memdesc:ae109848a6a58e6d47bee382355d2486b"><td class="mdescLeft">&#160;</td><td class="mdescRight">possible kinds of Type  <a href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae109848a6a58e6d47bee382355d2486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ea078f1cc061bca6ad1e80fbf47e8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2ea078f1cc061bca6ad1e80fbf47e8ed">FunctionGetAttr</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;func, const std::string &amp;key)</td></tr>
<tr class="separator:a2ea078f1cc061bca6ad1e80fbf47e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5a8f46a189aefa29de344e660bb752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#abc5a8f46a189aefa29de344e660bb752">FunctionSetAttr</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;func, const std::string &amp;key, const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;data)</td></tr>
<tr class="separator:abc5a8f46a189aefa29de344e660bb752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fa11ab9f53b70447210c47f34f313b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a96fa11ab9f53b70447210c47f34f313b">RelayPrint</a> (const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;node, bool show_meta_data=true, <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; std::string(<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>)&gt; annotate=nullptr)</td></tr>
<tr class="memdesc:a96fa11ab9f53b70447210c47f34f313b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print node as text format.  <a href="#a96fa11ab9f53b70447210c47f34f313b">More...</a><br /></td></tr>
<tr class="separator:a96fa11ab9f53b70447210c47f34f313b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9755f3fdc54686fe1438262d050c749f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9755f3fdc54686fe1438262d050c749f">PostOrderVisit</a> (const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;node, std::function&lt; void(const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a9755f3fdc54686fe1438262d050c749f"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#a9755f3fdc54686fe1438262d050c749f">More...</a><br /></td></tr>
<tr class="separator:a9755f3fdc54686fe1438262d050c749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cfa0b6a4537989b886d47767526726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad7cfa0b6a4537989b886d47767526726">Bind</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const tvm::Map&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &gt; &amp;binds)</td></tr>
<tr class="separator:ad7cfa0b6a4537989b886d47767526726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707333b716a42aefca7bddd721ebd668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>(<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a707333b716a42aefca7bddd721ebd668">CreateInterpreter</a> (<a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> mod, DLContext context, <a class="el" href="classtvm_1_1Target.html">Target</a> target)</td></tr>
<tr class="memdesc:a707333b716a42aefca7bddd721ebd668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Interpreter function that can evaluate an expression and produce a value.  <a href="#a707333b716a42aefca7bddd721ebd668">More...</a><br /></td></tr>
<tr class="separator:a707333b716a42aefca7bddd721ebd668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83708b95814bb9db25b569f0ce0658c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab83708b95814bb9db25b569f0ce0658c">RELAY_DEFINE_NODE_REF</a> (Closure, <a class="el" href="classtvm_1_1relay_1_1ClosureNode.html">ClosureNode</a>, <a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>)</td></tr>
<tr class="separator:ab83708b95814bb9db25b569f0ce0658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58735dd1f28983e1e0eaabbcffc0c8d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a58735dd1f28983e1e0eaabbcffc0c8d4">RELAY_DEFINE_NODE_REF</a> (TupleValue, <a class="el" href="structtvm_1_1relay_1_1TupleValueNode.html">TupleValueNode</a>, <a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>)</td></tr>
<tr class="separator:a58735dd1f28983e1e0eaabbcffc0c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8a86886b82ccf0502e3a2394b3530"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad1a8a86886b82ccf0502e3a2394b3530">RELAY_DEFINE_NODE_REF</a> (TensorValue, <a class="el" href="structtvm_1_1relay_1_1TensorValueNode.html">TensorValueNode</a>, <a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>)</td></tr>
<tr class="separator:ad1a8a86886b82ccf0502e3a2394b3530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae06ed7292f3e1876bb0f0faaa0b20c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aae06ed7292f3e1876bb0f0faaa0b20c4">RELAY_DEFINE_NODE_REF</a> (RefValue, <a class="el" href="structtvm_1_1relay_1_1RefValueNode.html">RefValueNode</a>, <a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>)</td></tr>
<tr class="separator:aae06ed7292f3e1876bb0f0faaa0b20c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ff1faeb59936c0fb4bc37f62a90ac1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a87ff1faeb59936c0fb4bc37f62a90ac1">RELAY_DEFINE_NODE_REF</a> (ConstructorValue, <a class="el" href="structtvm_1_1relay_1_1ConstructorValueNode.html">ConstructorValueNode</a>, <a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>)</td></tr>
<tr class="separator:a87ff1faeb59936c0fb4bc37f62a90ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b20096f7b7e1d6f25e4952ce8d360f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a12b20096f7b7e1d6f25e4952ce8d360f">IsPrimitiveOp</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a12b20096f7b7e1d6f25e4952ce8d360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that an expression is a "primtive operator".  <a href="#a12b20096f7b7e1d6f25e4952ce8d360f">More...</a><br /></td></tr>
<tr class="separator:a12b20096f7b7e1d6f25e4952ce8d360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b9049a14e8505f6ed6a85b0888442e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab2b9049a14e8505f6ed6a85b0888442e">InferType</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:ab2b9049a14e8505f6ed6a85b0888442e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression.  <a href="#ab2b9049a14e8505f6ed6a85b0888442e">More...</a><br /></td></tr>
<tr class="separator:ab2b9049a14e8505f6ed6a85b0888442e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efdc29b690d3c2a6bc432aedaf6b523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a8efdc29b690d3c2a6bc432aedaf6b523">InferType</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;f, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod, const <a class="el" href="classtvm_1_1relay_1_1GlobalVar.html">GlobalVar</a> &amp;<a class="el" href="namespacetvm.html#a24ff73c81db64909b233c8a2a5dc635b">var</a>)</td></tr>
<tr class="memdesc:a8efdc29b690d3c2a6bc432aedaf6b523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of a function as if it is mapped to var in the mod.  <a href="#a8efdc29b690d3c2a6bc432aedaf6b523">More...</a><br /></td></tr>
<tr class="separator:a8efdc29b690d3c2a6bc432aedaf6b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edcabb111b86a0987f3c4c4fa8af68e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486b">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0edcabb111b86a0987f3c4c4fa8af68e">KindCheck</a> (const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;t, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:a0edcabb111b86a0987f3c4c4fa8af68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that types are well kinded by applying "kinding rules".  <a href="#a0edcabb111b86a0987f3c4c4fa8af68e">More...</a><br /></td></tr>
<tr class="separator:a0edcabb111b86a0987f3c4c4fa8af68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8a41f4d5e1698684fe03446776c799"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ade8a41f4d5e1698684fe03446776c799">AlphaEqual</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;e1, const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;e2)</td></tr>
<tr class="memdesc:ade8a41f4d5e1698684fe03446776c799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions for structural equivalence.  <a href="#ade8a41f4d5e1698684fe03446776c799">More...</a><br /></td></tr>
<tr class="separator:ade8a41f4d5e1698684fe03446776c799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e72c6921843a960ac588a8c60253d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a396e72c6921843a960ac588a8c60253d">AlphaEqual</a> (const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;t1, const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;t2)</td></tr>
<tr class="memdesc:a396e72c6921843a960ac588a8c60253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two types for structural equivalence.  <a href="#a396e72c6921843a960ac588a8c60253d">More...</a><br /></td></tr>
<tr class="separator:a396e72c6921843a960ac588a8c60253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dde25d981d5b506115dd4dba7f67b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a59dde25d981d5b506115dd4dba7f67b7">WellFormed</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a59dde25d981d5b506115dd4dba7f67b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once.  <a href="#a59dde25d981d5b506115dd4dba7f67b7">More...</a><br /></td></tr>
<tr class="separator:a59dde25d981d5b506115dd4dba7f67b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc32688b446d3574932554f6b8c2df"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0bcc32688b446d3574932554f6b8c2df">BoundVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0bcc32688b446d3574932554f6b8c2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from expression expr.  <a href="#a0bcc32688b446d3574932554f6b8c2df">More...</a><br /></td></tr>
<tr class="separator:a0bcc32688b446d3574932554f6b8c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af2c5771c67f06c0af32c7b4b4269e73f">FreeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:af2c5771c67f06c0af32c7b4b4269e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free type parameters from expression expr.  <a href="#af2c5771c67f06c0af32c7b4b4269e73f">More...</a><br /></td></tr>
<tr class="separator:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6b1e94cf8d97514fe4a9493a0dec1559">AllVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all variables from expression expr.  <a href="#a6b1e94cf8d97514fe4a9493a0dec1559">More...</a><br /></td></tr>
<tr class="separator:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c1cf787ee89bbf569ce3e3949c0f9"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af22c1cf787ee89bbf569ce3e3949c0f9">FreeTypeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:af22c1cf787ee89bbf569ce3e3949c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from expression expr.  <a href="#af22c1cf787ee89bbf569ce3e3949c0f9">More...</a><br /></td></tr>
<tr class="separator:af22c1cf787ee89bbf569ce3e3949c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d12dbc2a761993a8687d0128cfcc7"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1b8d12dbc2a761993a8687d0128cfcc7">FreeTypeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;t, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:a1b8d12dbc2a761993a8687d0128cfcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from type t.  <a href="#a1b8d12dbc2a761993a8687d0128cfcc7">More...</a><br /></td></tr>
<tr class="separator:a1b8d12dbc2a761993a8687d0128cfcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82fe36f44f392afc2f4928fe69c246"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0f82fe36f44f392afc2f4928fe69c246">BoundTypeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:a0f82fe36f44f392afc2f4928fe69c246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from expression expr.  <a href="#a0f82fe36f44f392afc2f4928fe69c246">More...</a><br /></td></tr>
<tr class="separator:a0f82fe36f44f392afc2f4928fe69c246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9f82e989e3a2b34ea453eb4372dafd"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aba9f82e989e3a2b34ea453eb4372dafd">BoundTypeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;t, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:aba9f82e989e3a2b34ea453eb4372dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from type t.  <a href="#aba9f82e989e3a2b34ea453eb4372dafd">More...</a><br /></td></tr>
<tr class="separator:aba9f82e989e3a2b34ea453eb4372dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e422f6ecaa0c8866f8e2e21205d512"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a67e422f6ecaa0c8866f8e2e21205d512">AllTypeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:a67e422f6ecaa0c8866f8e2e21205d512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in expression expr.  <a href="#a67e422f6ecaa0c8866f8e2e21205d512">More...</a><br /></td></tr>
<tr class="separator:a67e422f6ecaa0c8866f8e2e21205d512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d0ab30f64b608f349c1a879a2df67"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; <a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aaf5d0ab30f64b608f349c1a879a2df67">AllTypeVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;t, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:aaf5d0ab30f64b608f349c1a879a2df67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in type t.  <a href="#aaf5d0ab30f64b608f349c1a879a2df67">More...</a><br /></td></tr>
<tr class="separator:aaf5d0ab30f64b608f349c1a879a2df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23a6d66dcae2eb70b3df7f1e2ba5674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af23a6d66dcae2eb70b3df7f1e2ba5674">DeadCodeElimination</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af23a6d66dcae2eb70b3df7f1e2ba5674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove expressions which does not effect the program result.  <a href="#af23a6d66dcae2eb70b3df7f1e2ba5674">More...</a><br /></td></tr>
<tr class="separator:af23a6d66dcae2eb70b3df7f1e2ba5674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc50940d727a51be83d381961f7be35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#affc50940d727a51be83d381961f7be35">FoldConstant</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:affc50940d727a51be83d381961f7be35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions.  <a href="#affc50940d727a51be83d381961f7be35">More...</a><br /></td></tr>
<tr class="separator:affc50940d727a51be83d381961f7be35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e15fd72ed6df857d9e724590c332e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac3e15fd72ed6df857d9e724590c332e0">FuseOps</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, int fuse_opt_level)</td></tr>
<tr class="memdesc:ac3e15fd72ed6df857d9e724590c332e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse operations into expr into seperate functions.  <a href="#ac3e15fd72ed6df857d9e724590c332e0">More...</a><br /></td></tr>
<tr class="separator:ac3e15fd72ed6df857d9e724590c332e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356667d81a80e25dafc6a831c1a3ddb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a356667d81a80e25dafc6a831c1a3ddb9">ForwardRewrite</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const std::string &amp;rewrite_map_attr_name, std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt; fcontext=nullptr, std::function&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:a356667d81a80e25dafc6a831c1a3ddb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order.  <a href="#a356667d81a80e25dafc6a831c1a3ddb9">More...</a><br /></td></tr>
<tr class="separator:a356667d81a80e25dafc6a831c1a3ddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b4af7a7e6c47743f02ccf37325b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acd5b4af7a7e6c47743f02ccf37325b0c">ForwardRewrite</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="namespacetvm_1_1relay.html#a4f6e323b3a8cb6df7969cfcca6fd5165">FForwardRewrite</a> &amp;rewrite_func, std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt; fcontext=nullptr, std::function&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:acd5b4af7a7e6c47743f02ccf37325b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order.  <a href="#acd5b4af7a7e6c47743f02ccf37325b0c">More...</a><br /></td></tr>
<tr class="separator:acd5b4af7a7e6c47743f02ccf37325b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917e50fbb560a15995e8a617d65d1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7917e50fbb560a15995e8a617d65d1ab">RewriteAnnotatedOps</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr, int fallback_device)</td></tr>
<tr class="memdesc:a7917e50fbb560a15995e8a617d65d1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="#a7917e50fbb560a15995e8a617d65d1ab">More...</a><br /></td></tr>
<tr class="separator:a7917e50fbb560a15995e8a617d65d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e35e7086b1f79ae55651500f94116b"><td class="memItemLeft" align="right" valign="top">Map&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>, <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab6e35e7086b1f79ae55651500f94116b">CollectDeviceInfo</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab6e35e7086b1f79ae55651500f94116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the device mapping information of each expression.  <a href="#ab6e35e7086b1f79ae55651500f94116b">More...</a><br /></td></tr>
<tr class="separator:ab6e35e7086b1f79ae55651500f94116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b53ca4ace01a21b39912372ffc78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ace8b53ca4ace01a21b39912372ffc78f">ToANormalForm</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;e, const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:ace8b53ca4ace01a21b39912372ffc78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF).  <a href="#ace8b53ca4ace01a21b39912372ffc78f">More...</a><br /></td></tr>
<tr class="separator:ace8b53ca4ace01a21b39912372ffc78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4041be7958bc78d75f83562bfdb9bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae4041be7958bc78d75f83562bfdb9bd9">ToGraphNormalForm</a> (const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:ae4041be7958bc78d75f83562bfdb9bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let binding and directly share via pointer instead.  <a href="#ae4041be7958bc78d75f83562bfdb9bd9">More...</a><br /></td></tr>
<tr class="separator:ae4041be7958bc78d75f83562bfdb9bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Relay: a high level functional IR for TVM. </p>
<p>This namespace contains the abstract syntax tree, and other essential data structures for the Relay IR.</p>
<p>You can find more about Relay by reading the language reference. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4cda5e77824033b608635bc43e31c2e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a4cda5e77824033b608635bc43e31c2e5">tvm::relay::DataType</a> = typedef ::tvm::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Content data type. </p>

</div>
</div>
<a class="anchor" id="a4f6e323b3a8cb6df7969cfcca6fd5165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a4f6e323b3a8cb6df7969cfcca6fd5165">tvm::relay::FForwardRewrite</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a>&amp; ref_call, const Array&lt;<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&gt;&amp; new_args, const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward rewriting rule for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_call</td><td>The reference old call type to be rewritten. We can make use of the op and type information. </td></tr>
    <tr><td class="paramname">new_args</td><td>The new arguments (some of them could be <a class="el" href="classtvm_1_1relay_1_1TempExpr.html">TempExpr</a>). </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context information about ref_call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewriten result call, can also return nullptr, which indicate the rewriter should use the default fallback rule that realizes all its input and compose the call.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When we register the function, we can register a different signature with ctx to be a specific node type. </dd></dl>

</div>
</div>
<a class="anchor" id="a9abada45a4f21ae750c1caba923f1059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a9abada45a4f21ae750c1caba923f1059">tvm::relay::FPrimalGradient</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&gt;(const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&amp; orig_call, const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&amp; output_grad)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gradient for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_call</td><td>the original <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>.</td></tr>
    <tr><td class="paramname">output_grad</td><td>the gradient of the <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gradient for each parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a016486a28db88f965c28e965f5b9a2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a016486a28db88f965c28e965f5b9a2e3">tvm::relay::FTVMAlterOpLayout</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const Array&lt;<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>&gt;&amp; args, const Array&lt;<a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&gt;&amp; tinfos)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate the layout of operators or replace the operator with other expressions. This function will be invoked in AlterOpLayout pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">tinfos</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aa35ff89f08378b7f98416eee0d17f371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aa35ff89f08378b7f98416eee0d17f371">tvm::relay::FTVMCompute</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; Array&lt;<a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const Array&lt;<a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&gt;&amp; inputs, const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a>&amp; out_type, const <a class="el" href="classtvm_1_1Target.html">Target</a>&amp; target)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation description interface. </p>
<dl class="section note"><dt>Note</dt><dd>This function have a special convention for functions with tuple input/output.</dd></dl>
<p>So far we restrict tuple support to the following case:</p><ul>
<li><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> which takes a single tuple as input.</li>
<li><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> which outputs a single tuple.</li>
</ul>
<p>In both cases, the tuple is flattened as array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the primitive </td></tr>
    <tr><td class="paramname">inputs</td><td>The input tensors. </td></tr>
    <tr><td class="paramname">out_type</td><td>The output type information &amp; these are always placeholders. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output compute description of the operator. </dd></dl>

</div>
</div>
<a class="anchor" id="a42de56668e3098b3916f32504df9f99f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a42de56668e3098b3916f32504df9f99f">tvm::relay::FTVMSchedule</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Schedule.html">Schedule</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const Array&lt;<a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&gt;&amp; outs, const <a class="el" href="classtvm_1_1Target.html">Target</a>&amp; target)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the computation schedule for op whose root is at current op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the node. </td></tr>
    <tr><td class="paramname">outs</td><td>The output tensors. </td></tr>
    <tr><td class="paramname">target</td><td>The build target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>schedule The computation schedule. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0c96f3d3efdabd227ccfe1c60cf396a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac0c96f3d3efdabd227ccfe1c60cf396a">tvm::relay::IndexExpr</a> = typedef ::tvm::Expr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolic expression for tensor shape. </p>

</div>
</div>
<a class="anchor" id="ade06e0c823a00b400c9aeafc2bbf4ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ade06e0c823a00b400c9aeafc2bbf4ae8">tvm::relay::NodeEqual</a> = typedef ::tvm::NodeEqual</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality check function for nodes. </p>

</div>
</div>
<a class="anchor" id="ac83a9bc802ced1fec6d33f26deeb7f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac83a9bc802ced1fec6d33f26deeb7f07">tvm::relay::NodeHash</a> = typedef ::tvm::NodeHash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash function for nodes. e.g. std::unordered_map&lt;Expr, Value, NodeHash, NodeEqual&gt; </p>

</div>
</div>
<a class="anchor" id="ac3c3c5d68fac2fe3bfe69cfbe0305b7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">tvm::relay::NodeRef</a> = typedef tvm::NodeRef</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We always used NodeRef for referencing nodes. </p>
<p>By default, NodeRef is a std::shared_ptr of node </p>

</div>
</div>
<a class="anchor" id="ab4c835287dfc5ec074ea8431bcebbb17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab4c835287dfc5ec074ea8431bcebbb17">tvm::relay::TNonComputational</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the operator as non-computational. </p>

</div>
</div>
<a class="anchor" id="afb8a8d4dd43830d4ce7d566abcd1c450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afb8a8d4dd43830d4ce7d566abcd1c450">tvm::relay::TOpIsStateful</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether operator is stateful or contain internal state. </p>
<p>All the primitive ops we registered so far are pure. This attribute is left for potential future compatible reasons. We can always work around the stateful ops by adding an additional handle argument and return it. </p>

</div>
</div>
<a class="anchor" id="a5dab2ddae20ac7564a81ab3a0a9aba76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a5dab2ddae20ac7564a81ab3a0a9aba76">tvm::relay::TOpPattern</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the operator pattern </p>

</div>
</div>
<a class="anchor" id="a2efecf5205823e4e454faeca883da90c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2efecf5205823e4e454faeca883da90c">tvm::relay::TypeRelationFn</a> = typedef <a class="el" href="classtvm_1_1TypedEnvFunc.html">TypedEnvFunc</a>&lt;bool(const Array&lt;<a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a>&gt;&amp; args, int num_inputs, const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1relay_1_1TypeReporter.html">TypeReporter</a>&amp; reporter)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User defined type constraint function. </p>
<p><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> the input type information can be used to fully decide the IncompleteTypes, then the function should call reporter.Assign to report the new types, and return true. Otherwise, the function should return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to the relation. The types are stored in the form of [input_type_0, input_type_1, ... input_type_n, output_type_0, output_type_1, ... output_type_m]</td></tr>
    <tr><td class="paramname">num_inputs</td><td>Number of input types in the args. </td></tr>
    <tr><td class="paramname">attrs</td><td>The additional attributes of the operator. </td></tr>
    <tr><td class="paramname">reporter</td><td>The reporter to report solution to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if This relation cannot be resolved. true if this relation has been resolved. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ae109848a6a58e6d47bee382355d2486b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486b">tvm::relay::Kind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>possible kinds of <a class="el" href="classtvm_1_1relay_1_1Type.html" title="Type is the base type of relay type hiearchy. ">Type</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486ba3f91eeea0e99e899ac52149dc66ad053"></a>kType&#160;</td><td class="fielddoc">
<p>template variable in shape expression </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486ba5a56168a566ff6e421c72a9f7d060c44"></a>kShapeVar&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486baa992fa91a16daaf1380f1636e06963a6"></a>kBaseType&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486babcb7413699d5999795bb570b28d5ea51"></a>kShape&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486bac9f0b6820d2163ddc0da5d57e737d10e"></a>kConstraint&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486ba20abcbd2672c0e96fb5e57a94d341524"></a>kAdtHandle&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae109848a6a58e6d47bee382355d2486ba8fd779c0419a9b5631959203403bfd92"></a>kTypeData&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">tvm::relay::OpPatternKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator pattern used in graph fusion </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a8c63d345994ce14eb197df6ad22de3aa"></a>kElemWise&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a3c016b63ef8869468ab565c862713245"></a>kBroadcast&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a7f703d1ae163ba4e6bef88357a232e00"></a>kInjective&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578ad282ac05b650598c3bfb559dc62a0738"></a>kCommReduce&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578ab9b265465c486425c2f60cd4057e2ef4"></a>kOutEWiseFusable&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a3cb3cec00829ebd525feba875f2d6ac1"></a>kOpaque&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a67e422f6ecaa0c8866f8e2e21205d512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a>&gt; tvm::relay::AllTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all type variables in expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of type vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf5d0ab30f64b608f349c1a879a2df67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a>&gt; tvm::relay::AllTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all type variables in type t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b1e94cf8d97514fe4a9493a0dec1559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::AllVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all variables from expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ade8a41f4d5e1698684fe03446776c799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::AlphaEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two expressions for structural equivalence. </p>
<p>This comparison operator respects scoping and compares expressions without regard to variable choice.</p>
<p>For example: <code>let x = 1 in x</code> is equal to <code>let y = 1 in y</code>.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence">https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>The left hand expression. </td></tr>
    <tr><td class="paramname">e2</td><td>The right hand expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a396e72c6921843a960ac588a8c60253d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::AlphaEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two types for structural equivalence. </p>
<p>This comparison operator respects scoping and compares expressions without regard to variable choice.</p>
<p>For example: <code>forall s, <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a>[f32, s]</code> is equal to <code>forall w, <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a>[f32, w]</code>.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence">https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>The left hand type. </td></tr>
    <tr><td class="paramname">t2</td><td>The right hand type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ad7cfa0b6a4537989b886d47767526726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tvm::Map&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f82fe36f44f392afc2f4928fe69c246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a>&gt; tvm::relay::BoundTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound type variables from expression expr. </p>
<p>Bound variables are all type variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound type vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aba9f82e989e3a2b34ea453eb4372dafd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a>&gt; tvm::relay::BoundTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound type variables from type t. </p>
<p>Bound variables are all type variables that are declared in the type. They only have meaning inside that type, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bcc32688b446d3574932554f6b8c2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from expression expr. </p>
<p>Bound variables are all variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e35e7086b1f79ae55651500f94116b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Map&lt;<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>, <a class="el" href="classtvm_1_1Integer.html">Integer</a>&gt; tvm::relay::CollectDeviceInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the device mapping information of each expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The device mapping. </dd></dl>

</div>
</div>
<a class="anchor" id="a707333b716a42aefca7bddd721ebd668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>(<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>)&gt; tvm::relay::CreateInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a>&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLContext&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Target.html">Target</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Interpreter function that can evaluate an expression and produce a value. </p>
<p>The resulting value can be passed to Python, making it easy to use for testing and debugging.</p>
<p>The interpreter interprets the program fragments not supported by the TVM runtime, although the interpreter is naively implemented it uses TVM operators for evaluating all operators.</p>
<p>Our intent is that this will never be the most efficient implementation of Relay's semantics, but a readable and clear one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The function module. </td></tr>
    <tr><td class="paramname">context</td><td>The primary context that the interepreter runs on. </td></tr>
    <tr><td class="paramname">target</td><td>Compiler target flag to compile the functions on the context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that takes in an expression and returns a value. </dd></dl>

</div>
</div>
<a class="anchor" id="af23a6d66dcae2eb70b3df7f1e2ba5674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::DeadCodeElimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove expressions which does not effect the program result. </p>
<p>It will remove let bindings which are not referenced, and branches that will not be entered.</p>
<p>For example, this pass should turn <code>let a = 1 in 2</code> into <code>2</code>, as the value of the expression does not depend on a. Another example is <code>if (true) then 1 else 2</code> will be optimized into 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression to optimize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the optimized expression. </dd></dl>

</div>
</div>
<a class="anchor" id="affc50940d727a51be83d381961f7be35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::FoldConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold constant expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to be optimized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimized expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a356667d81a80e25dafc6a831c1a3ddb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::ForwardRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rewrite_map_attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fcontext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fmulti_ref_trigger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply rewrite rules to rewrite the expr in post DFS order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">rewrite_map_attr_name</td><td>The <a class="el" href="classtvm_1_1relay_1_1Op.html" title="Operator reference class. ">Op</a>'s attr name which corresponds to the rewrite rule function. </td></tr>
    <tr><td class="paramname">fcontext</td><td>Additional callback to provide context argument for each call node. </td></tr>
    <tr><td class="paramname">fmulti_ref_trigger</td><td>Transformation function to be called when an <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> consumed by multiple callers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten expression. </dd></dl>

</div>
</div>
<a class="anchor" id="acd5b4af7a7e6c47743f02ccf37325b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::ForwardRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a4f6e323b3a8cb6df7969cfcca6fd5165">FForwardRewrite</a> &amp;&#160;</td>
          <td class="paramname"><em>rewrite_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fcontext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fmulti_ref_trigger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply rewrite rules to rewrite the expr in post DFS order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">rewrite_func</td><td>The rewrite func that will apply to all operators. </td></tr>
    <tr><td class="paramname">fcontext</td><td>Additional callback to provide context argument for each call node. </td></tr>
    <tr><td class="paramname">fmulti_ref_trigger</td><td>Transformation function to be called when an <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> consumed by multiple callers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten expression. </dd></dl>

</div>
</div>
<a class="anchor" id="af22c1cf787ee89bbf569ce3e3949c0f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a>&gt; tvm::relay::FreeTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free TypeVars from expression expr. </p>
<p>Free type parameters are type parameters that are not bound by a function type in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order visited by expr. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8d12dbc2a761993a8687d0128cfcc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1TypeVar.html">TypeVar</a>&gt; tvm::relay::FreeTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free TypeVars from type t. </p>
<p>Free type parameters are type parameters that are not bound by a function type in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a class="anchor" id="af2c5771c67f06c0af32c7b4b4269e73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::Array&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::FreeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free type parameters from expression expr. </p>
<p>Free variables are variables that are not bound by a let or a function parameter in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ea078f1cc061bca6ad1e80fbf47e8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> tvm::relay::FunctionGetAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc5a8f46a189aefa29de344e660bb752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::FunctionSetAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3e15fd72ed6df857d9e724590c332e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::FuseOps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fuse_opt_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse operations into expr into seperate functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">fuse_opt_level</td><td>Optimization level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimized expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b9049a14e8505f6ed6a85b0888442e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::InferType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression. </p>
<p>The result of type checking is a new expression with unambigous type information filled in, as well as it's checked type field populated with the result type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to type check. </td></tr>
    <tr><td class="paramname">mod</td><td>The module used for referencing global functions, can be None.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type checked expression with its checked_type field populated. </dd></dl>

</div>
</div>
<a class="anchor" id="a8efdc29b690d3c2a6bc432aedaf6b523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::InferType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1GlobalVar.html">GlobalVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of a function as if it is mapped to var in the mod. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
    <tr><td class="paramname">mod</td><td>The module used for referencing global functions. </td></tr>
    <tr><td class="paramname">var</td><td>The global variable corresponding to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type checked <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> with its checked_type field populated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function mutates mod and is not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a12b20096f7b7e1d6f25e4952ce8d360f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::IsPrimitiveOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that an expression is a "primtive operator". </p>
<p>Will return true if the expression is an operator which matches the form of primtive operators registered directly by the Relay codebase.</p>
<p>That is the arguments are all type variables, and there is a single type relation applied to the input and output types. </p>

</div>
</div>
<a class="anchor" id="a0edcabb111b86a0987f3c4c4fa8af68e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#ae109848a6a58e6d47bee382355d2486b">Kind</a> tvm::relay::KindCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that types are well kinded by applying "kinding rules". </p>
<p>This pass ensures we do not do things that violate the design of the type system when writing down types.</p>
<p>For example tensors are not allowed to contain functions in Relay.</p>
<p>We check this by ensuring the <code>dtype</code> field of a <a class="el" href="classtvm_1_1Tensor.html" title="Tensor structure representing a possible input, or intermediate computation result. ">Tensor</a> always contains a data type such as <code>int</code>, <code>float</code>, <code>uint</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type to check. </td></tr>
    <tr><td class="paramname">mod</td><td>The global module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The kind of the passed type. </dd></dl>

</div>
</div>
<a class="anchor" id="a9755f3fdc54686fe1438262d050c749f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab83708b95814bb9db25b569f0ce0658c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relay::RELAY_DEFINE_NODE_REF </td>
          <td>(</td>
          <td class="paramtype">Closure&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1ClosureNode.html">ClosureNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58735dd1f28983e1e0eaabbcffc0c8d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relay::RELAY_DEFINE_NODE_REF </td>
          <td>(</td>
          <td class="paramtype">TupleValue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvm_1_1relay_1_1TupleValueNode.html">TupleValueNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1a8a86886b82ccf0502e3a2394b3530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relay::RELAY_DEFINE_NODE_REF </td>
          <td>(</td>
          <td class="paramtype">TensorValue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvm_1_1relay_1_1TensorValueNode.html">TensorValueNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae06ed7292f3e1876bb0f0faaa0b20c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relay::RELAY_DEFINE_NODE_REF </td>
          <td>(</td>
          <td class="paramtype">RefValue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvm_1_1relay_1_1RefValueNode.html">RefValueNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87ff1faeb59936c0fb4bc37f62a90ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relay::RELAY_DEFINE_NODE_REF </td>
          <td>(</td>
          <td class="paramtype">ConstructorValue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtvm_1_1relay_1_1ConstructorValueNode.html">ConstructorValueNode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relay_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a96fa11ab9f53b70447210c47f34f313b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::relay::RelayPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#ac3c3c5d68fac2fe3bfe69cfbe0305b7a">NodeRef</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_meta_data</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; std::string(<a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotate</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print node as text format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to be printed. </td></tr>
    <tr><td class="paramname">show_meta_data</td><td>Whether to print meta data section. </td></tr>
    <tr><td class="paramname">annotate</td><td>An optional callback function for attaching additional comment block to an expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text representation. </dd></dl>

</div>
</div>
<a class="anchor" id="a7917e50fbb560a15995e8a617d65d1ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::RewriteAnnotatedOps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the annotated program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">fallback_device</td><td>The fallback device which is the default device for operators without annotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated program. </dd></dl>

</div>
</div>
<a class="anchor" id="ace8b53ca4ace01a21b39912372ffc78f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::ToANormalForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtvm_1_1relay_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF). </p>
<p>It will turn an expression that is in a graph form (with sharing implicit), to an expression with explicit sharing (A-Normal Form).</p>
<p>The scope of the root expression is the global scope.</p>
<p>The scope of any non root expression is the least common ancestor of all it's scope.</p>
<p>Values are ordered by post-DFS order in each scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression to observably share</td></tr>
    <tr><td class="paramname">mod</td><td>The module used for referencing global functions, can be None.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression in A-Normal Form </dd></dl>

</div>
</div>
<a class="anchor" id="ae4041be7958bc78d75f83562bfdb9bd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> tvm::relay::ToGraphNormalForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove let binding and directly share via pointer instead. </p>
<p>It will remove all let binding, and turn all of the variable bound by let into direct pointer reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expression in graph normal form. </dd></dl>

</div>
</div>
<a class="anchor" id="a59dde25d981d5b506115dd4dba7f67b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::WellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once. </p>
<p>For example, the expression <code>let x = 1 in let x = 2 in 3</code> bound x twice.</p>
<p><code>let f = (\x -&gt; x) in let g = (\x -&gt; x + 1) in f(g(2))</code> also bound x twice, although x is not shadowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff all <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> in expr is bound at most once. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 6 2019 11:14:41 for tvm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
