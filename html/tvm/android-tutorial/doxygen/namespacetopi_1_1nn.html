<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: topi::nn Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetopi.html">topi</a></li><li class="navelem"><a class="el" href="namespacetopi_1_1nn.html">nn</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">topi::nn Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac531cfce9c3a031fa25cfb6ed1f9b95b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> : int { <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95babbfb6c4315c8b57e558600af1515d3d8">kAvgPool</a>, 
<a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95ba3a406a1361a3c7ca311d3c514842c2f4">kMaxPool</a>
 }<tr class="memdesc:ac531cfce9c3a031fa25cfb6ed1f9b95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pooling type.  <a href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac531cfce9c3a031fa25cfb6ed1f9b95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ff671f2afa471ced1d689514e54dcc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a6ff671f2afa471ced1d689514e54dcc4">batch_matmul</a> (const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;y)</td></tr>
<tr class="memdesc:a6ff671f2afa471ced1d689514e54dcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation that calculates matrix multiplication in batch.  <a href="#a6ff671f2afa471ced1d689514e54dcc4">More...</a><br /></td></tr>
<tr class="separator:a6ff671f2afa471ced1d689514e54dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d149e272f65a8f9f9f11bd73d572f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a639d149e272f65a8f9f9f11bd73d572f">binarize_pack</a> (const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;data, int axis, std::string name=&quot;PackedInput&quot;, std::string tag=&quot;binarize_pack&quot;)</td></tr>
<tr class="memdesc:a639d149e272f65a8f9f9f11bd73d572f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binarization and bit-packing along a certain axis.  <a href="#a639d149e272f65a8f9f9f11bd73d572f">More...</a><br /></td></tr>
<tr class="separator:a639d149e272f65a8f9f9f11bd73d572f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc74c5f0fc13ae8d0406156cc9317210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#acc74c5f0fc13ae8d0406156cc9317210">binary_dense</a> (const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;data, const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;weight)</td></tr>
<tr class="memdesc:acc74c5f0fc13ae8d0406156cc9317210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary matrix multiplication using xor and bit-count.  <a href="#acc74c5f0fc13ae8d0406156cc9317210">More...</a><br /></td></tr>
<tr class="separator:acc74c5f0fc13ae8d0406156cc9317210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e2c0f77bb525852c9e37e5c242a6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ae3e2c0f77bb525852c9e37e5c242a6b5">dense</a> (const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;data, const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;weight, const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;bias)</td></tr>
<tr class="memdesc:ae3e2c0f77bb525852c9e37e5c242a6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation that calculates data * weight^T + bias.  <a href="#ae3e2c0f77bb525852c9e37e5c242a6b5">More...</a><br /></td></tr>
<tr class="separator:ae3e2c0f77bb525852c9e37e5c242a6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5ace5ba03fdc42733e88b66a9d80d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a5e5ace5ba03fdc42733e88b66a9d80d4">all</a> (Array&lt; Expr &gt; args)</td></tr>
<tr class="memdesc:a5e5ace5ba03fdc42733e88b66a9d80d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression of the logical and of all conditions in the arguments.  <a href="#a5e5ace5ba03fdc42733e88b66a9d80d4">More...</a><br /></td></tr>
<tr class="separator:a5e5ace5ba03fdc42733e88b66a9d80d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89db25b870b13ed4ab063d1b31bd1f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ae89db25b870b13ed4ab063d1b31bd1f9">dilate</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, Array&lt; Expr &gt; strides, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a>)</td></tr>
<tr class="memdesc:ae89db25b870b13ed4ab063d1b31bd1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilate data with zeros.  <a href="#ae89db25b870b13ed4ab063d1b31bd1f9">More...</a><br /></td></tr>
<tr class="separator:ae89db25b870b13ed4ab063d1b31bd1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84054f5c8010db45e80365c3c2c6e1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a84054f5c8010db45e80365c3c2c6e1d4">flatten</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a>)</td></tr>
<tr class="memdesc:a84054f5c8010db45e80365c3c2c6e1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the input tensor into a 2-D tensor by collapsing higher dimensions. This requires the input tensor to have constant sized dimensions.  <a href="#a84054f5c8010db45e80365c3c2c6e1d4">More...</a><br /></td></tr>
<tr class="separator:a84054f5c8010db45e80365c3c2c6e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e884f4ede70b00c5d4ea5dd95569b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a19e884f4ede70b00c5d4ea5dd95569b4">l2_normalize</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;data, float eps, const Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;axis, std::string name=&quot;tensor&quot;, std::string tag=&quot;l2_normalize&quot;)</td></tr>
<tr class="memdesc:a19e884f4ede70b00c5d4ea5dd95569b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 normalization inference operator.  <a href="#a19e884f4ede70b00c5d4ea5dd95569b4">More...</a><br /></td></tr>
<tr class="separator:a19e884f4ede70b00c5d4ea5dd95569b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded232c2572637db6adc7cf5f0b35b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a0ded232c2572637db6adc7cf5f0b35b2">lrn</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;data, int size, int axis=1, float alpha=0.0001, float beta=0.75, float bias=2, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a>)</td></tr>
<tr class="memdesc:a0ded232c2572637db6adc7cf5f0b35b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local response normalization inference operator.  <a href="#a0ded232c2572637db6adc7cf5f0b35b2">More...</a><br /></td></tr>
<tr class="separator:a0ded232c2572637db6adc7cf5f0b35b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9516b844130a2189ad2989b646ec2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ae9516b844130a2189ad2989b646ec2b1">scale_shift_nchw</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;scale, const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;shift, std::string name=&quot;ScaleShift&quot;, std::string tag=<a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a>)</td></tr>
<tr class="memdesc:ae9516b844130a2189ad2989b646ec2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and shift with NCHW order.  <a href="#ae9516b844130a2189ad2989b646ec2b1">More...</a><br /></td></tr>
<tr class="separator:ae9516b844130a2189ad2989b646ec2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19179f1b4a73a42b17ddf2f5fea46fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ab19179f1b4a73a42b17ddf2f5fea46fc">scale_shift_nhwc</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;scale, const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;shift, std::string name=&quot;ScaleShift&quot;, std::string tag=<a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a>)</td></tr>
<tr class="memdesc:ab19179f1b4a73a42b17ddf2f5fea46fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and shift with NHWC order.  <a href="#ab19179f1b4a73a42b17ddf2f5fea46fc">More...</a><br /></td></tr>
<tr class="separator:ab19179f1b4a73a42b17ddf2f5fea46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231b0a562c0047cd7be6ac70d13953c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a231b0a562c0047cd7be6ac70d13953c4">pool_impl</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, const Array&lt; Expr &gt; &amp;kernel_size, const Array&lt; Expr &gt; &amp;stride_size, const Array&lt; Expr &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const size_t height_axis, const size_t width_axis, bool count_include_pad)</td></tr>
<tr class="memdesc:a231b0a562c0047cd7be6ac70d13953c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on height and width dimension of data.  <a href="#a231b0a562c0047cd7be6ac70d13953c4">More...</a><br /></td></tr>
<tr class="separator:a231b0a562c0047cd7be6ac70d13953c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428e0ba6800ef89b8c1f97f0245e244d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a428e0ba6800ef89b8c1f97f0245e244d">find_height_width</a> (const std::string &amp;layout, int *height_axis, int *width_axis)</td></tr>
<tr class="separator:a428e0ba6800ef89b8c1f97f0245e244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6426a7a5ac45b0b761250468d967a01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ac6426a7a5ac45b0b761250468d967a01">pool</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, const Array&lt; Expr &gt; &amp;kernel_size, const Array&lt; Expr &gt; &amp;stride_size, const Array&lt; Expr &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCHW&quot;, bool count_include_pad=true)</td></tr>
<tr class="memdesc:ac6426a7a5ac45b0b761250468d967a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#ac6426a7a5ac45b0b761250468d967a01">More...</a><br /></td></tr>
<tr class="separator:ac6426a7a5ac45b0b761250468d967a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fe64687aa8bffee420bf282f2b8f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ac5fe64687aa8bffee420bf282f2b8f8c">global_pool</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, const std::string &amp;layout=&quot;NCHW&quot;)</td></tr>
<tr class="memdesc:ac5fe64687aa8bffee420bf282f2b8f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform global pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, ... are valid for global_pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#ac5fe64687aa8bffee420bf282f2b8f8c">More...</a><br /></td></tr>
<tr class="separator:ac5fe64687aa8bffee420bf282f2b8f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c845f2e02a677c556929d41a399e729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a1c845f2e02a677c556929d41a399e729">softmax</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, int axis=-1, std::string name=&quot;tensor&quot;, std::string tag=&quot;softmax_output&quot;)</td></tr>
<tr class="memdesc:a1c845f2e02a677c556929d41a399e729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Softmax activation.  <a href="#a1c845f2e02a677c556929d41a399e729">More...</a><br /></td></tr>
<tr class="separator:a1c845f2e02a677c556929d41a399e729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667b9b98da3fd9a918a603d1b8aad5d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a667b9b98da3fd9a918a603d1b8aad5d7">log_softmax</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;x, std::string name=&quot;tensor&quot;, std::string tag=&quot;log_softmax_output&quot;)</td></tr>
<tr class="memdesc:a667b9b98da3fd9a918a603d1b8aad5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log softmax activation.  <a href="#a667b9b98da3fd9a918a603d1b8aad5d7">More...</a><br /></td></tr>
<tr class="separator:a667b9b98da3fd9a918a603d1b8aad5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfd1fe1d62dc7745d9af8a7c3546164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#aadfd1fe1d62dc7745d9af8a7c3546164">upsampling</a> (const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;input, const Array&lt; Expr &gt; <a class="el" href="namespacetopi.html#a43c60d97fe19e05879b603c26e88fa21">shape</a>, std::string layout=&quot;NCHW&quot;, std::string mode=&quot;NEAREST_NEIGHBOR&quot;, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a>)</td></tr>
<tr class="memdesc:aadfd1fe1d62dc7745d9af8a7c3546164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upsample given tensor to given shape.  <a href="#aadfd1fe1d62dc7745d9af8a7c3546164">More...</a><br /></td></tr>
<tr class="separator:aadfd1fe1d62dc7745d9af8a7c3546164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac531cfce9c3a031fa25cfb6ed1f9b95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">topi::nn::PoolType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pooling type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac531cfce9c3a031fa25cfb6ed1f9b95babbfb6c4315c8b57e558600af1515d3d8"></a>kAvgPool&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac531cfce9c3a031fa25cfb6ed1f9b95ba3a406a1361a3c7ca311d3c514842c2f4"></a>kMaxPool&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5e5ace5ba03fdc42733e88b66a9d80d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Expr topi::nn::all </td>
          <td>(</td>
          <td class="paramtype">Array&lt; Expr &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new expression of the logical and of all conditions in the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to find the logical conjunction of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The logical conjunction expression </dd></dl>

</div>
</div>
<a class="anchor" id="a6ff671f2afa471ced1d689514e54dcc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> topi::nn::batch_matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an operation that calculates matrix multiplication in batch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Tensor with shape [batch, M, K] </td></tr>
    <tr><td class="paramname">y</td><td>Tensor with shape [batch, N, K]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, M, N] </dd></dl>

</div>
</div>
<a class="anchor" id="a639d149e272f65a8f9f9f11bd73d572f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> topi::nn::binarize_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;PackedInput&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;binarize_pack&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binarization and bit-packing along a certain axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>N-D tensor, can be any layout </td></tr>
    <tr><td class="paramname">axis</td><td>The axis along which to do binarization and bit-packing. This axis must have a size equal to an integer multiple of 32. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output tensor with dtype uint32 </dd></dl>

</div>
</div>
<a class="anchor" id="acc74c5f0fc13ae8d0406156cc9317210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> topi::nn::binary_dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary matrix multiplication using xor and bit-count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Tensor with shape [batch, in_dim], dtype is uint32 </td></tr>
    <tr><td class="paramname">weight</td><td>Tensor with shape [out_dim, in_dim], dtype is uint32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, out_dim], dtype is float32 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3e2c0f77bb525852c9e37e5c242a6b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> topi::nn::dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">tvm::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an operation that calculates data * weight^T + bias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Tensor with shape [batch, in_dim] </td></tr>
    <tr><td class="paramname">weight</td><td>Tensor with shape [out_dim, in_dim] </td></tr>
    <tr><td class="paramname">bias</td><td>Tensor with shape [out_dim]. Optional; to omit bias, pass Tensor()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, out_dim] </dd></dl>

</div>
</div>
<a class="anchor" id="ae89db25b870b13ed4ab063d1b31bd1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::dilate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; Expr &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dilate data with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor, this can have any number of dimensions and any layout. </td></tr>
    <tr><td class="paramname">strides</td><td>Dilation stride for each dimension. Stride 1 means no dilation. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="a428e0ba6800ef89b8c1f97f0245e244d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool topi::nn::find_height_width </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84054f5c8010db45e80365c3c2c6e1d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::flatten </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flattens the input tensor into a 2-D tensor by collapsing higher dimensions. This requires the input tensor to have constant sized dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2-D tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5fe64687aa8bffee420bf282f2b8f8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::global_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform global pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, ... are valid for global_pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor represent as layout </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. global-pooling supports any layout as long as 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the sub-dimension. For example, <code>NCHW16c</code> can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>H</code> and <code>W</code>, one can pass <code>NCHWc</code> as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout with height and width dimension size of 1. e.g., for NCHW, the output shape will be [batch, channel, 1, 1] </dd></dl>

</div>
</div>
<a class="anchor" id="a19e884f4ede70b00c5d4ea5dd95569b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::l2_normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;l2_normalize&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>L2 normalization inference operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input tensor. 4-D with shape [batch, channel, height, width] </td></tr>
    <tr><td class="paramname">eps</td><td>Epsilon to prevent div by 0 </td></tr>
    <tr><td class="paramname">axis</td><td>Axes over the normalization applied </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the l2 normalization operation </dd></dl>

</div>
</div>
<a class="anchor" id="a667b9b98da3fd9a918a603d1b8aad5d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;log_softmax_output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log softmax activation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. 2-D where log softmax is performed along the second dimension </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the log softmax operation </dd></dl>

</div>
</div>
<a class="anchor" id="a0ded232c2572637db6adc7cf5f0b35b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::lrn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.75</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bias</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Local response normalization inference operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input tensor. 4-D shape NCHW or NHWC </td></tr>
    <tr><td class="paramname">size</td><td>Integer to define normalisation window size </td></tr>
    <tr><td class="paramname">axis</td><td>Input data layout channel axis </td></tr>
    <tr><td class="paramname">alpha</td><td>Float scaling factor </td></tr>
    <tr><td class="paramname">beta</td><td>Exponent value </td></tr>
    <tr><td class="paramname">bias</td><td>Offset to avoid dividing by zero </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the Local response normalization operation </dd></dl>

</div>
</div>
<a class="anchor" id="ac6426a7a5ac45b0b761250468d967a01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of two ints: {kernel_height, kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of two ints: {stride_height, stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of two ints: {padding_height, padding_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. Pooling supports any layout as long as 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>H</code> and <code>W</code>, one can pass <code>NCHWc</code> as well. </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation when pool_type is 'avg'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in the same layout </dd></dl>

</div>
</div>
<a class="anchor" id="a231b0a562c0047cd7be6ac70d13953c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::pool_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>height_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on height and width dimension of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of two ints: {kernel_height, kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of two ints: {stride_height, stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of two ints: {padding_height, padding_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">height_axis</td><td>index of the height dimension </td></tr>
    <tr><td class="paramname">width_axis</td><td>index of the width dimension </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout order </dd></dl>

</div>
</div>
<a class="anchor" id="ae9516b844130a2189ad2989b646ec2b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::scale_shift_nchw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ScaleShift&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and shift with NCHW order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">shift</td><td>Shift tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the scale shift operation </dd></dl>

</div>
</div>
<a class="anchor" id="ab19179f1b4a73a42b17ddf2f5fea46fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::scale_shift_nhwc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ScaleShift&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and shift with NHWC order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">shift</td><td>Shift tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the scale shift operation </dd></dl>

</div>
</div>
<a class="anchor" id="a1c845f2e02a677c556929d41a399e729"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::softmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;softmax_output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Softmax activation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. Can be any dimension </td></tr>
    <tr><td class="paramname">axis</td><td>The channel axis along which softmax is performed </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the softmax operation </dd></dl>

</div>
</div>
<a class="anchor" id="aadfd1fe1d62dc7745d9af8a7c3546164"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Tensor.html">Tensor</a> topi::nn::upsampling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;NEAREST_NEIGHBOR&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upsample given tensor to given shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">shape</td><td>Output shape to upsample. </td></tr>
    <tr><td class="paramname">layout</td><td>input layout </td></tr>
    <tr><td class="paramname">mode</td><td>Angorithm to use (NEAREST_NEIGHBOR / BILINEAR) </td></tr>
    <tr><td class="paramname">name</td><td>Name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor upsampled to given shape </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 6 2019 11:14:40 for tvm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
