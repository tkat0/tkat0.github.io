<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: include/tvm/relay/pass.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b4c7d8e826c599ba55146c099a14beb5.html">tvm</a></li><li class="navelem"><a class="el" href="dir_63946bee875c6d52bce55e72a67a86ad.html">relay</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pass.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The set of Relay passes written in C++.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="ir_8h_source.html">tvm/ir.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2tvm_2packed__func__ext_8h_source.html">tvm/packed_func_ext.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="error_8h_source.html">tvm/relay/error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="relay_2expr_8h_source.html">tvm/relay/expr.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="relay_2module_8h_source.html">tvm/relay/module.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2tvm_2relay_2op__attr__types_8h_source.html">tvm/relay/op_attr_types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="type_8h_source.html">tvm/relay/type.h</a>&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pass.h:</div>
<div class="dyncontent">
<div class="center"><img src="include_2tvm_2relay_2pass_8h__incl.png" border="0" usemap="#include_2tvm_2relay_2pass_8h" alt=""/></div>
<map name="include_2tvm_2relay_2pass_8h" id="include_2tvm_2relay_2pass_8h">
<area shape="rect" id="node2" href="ir_8h.html" title="Additional high level nodes in the IR. " alt="" coords="1290,827,1361,853"/>
<area shape="rect" id="node29" href="include_2tvm_2packed__func__ext_8h.html" title="Extension package to PackedFunc This enales pass NodeRef types into/from PackedFunc. " alt="" coords="1739,603,1909,629"/>
<area shape="rect" id="node35" href="error_8h.html" title="The set of errors raised by Relay. " alt="" coords="859,80,987,107"/>
<area shape="rect" id="node38" href="relay_2expr_8h.html" title="Relay expression language. " alt="" coords="760,304,829,331"/>
<area shape="rect" id="node41" href="type_8h.html" title="Relay typed AST nodes. " alt="" coords="629,379,699,405"/>
<area shape="rect" id="node42" href="relay_2module_8h.html" title="The global environment: contains information needed to compile &amp; optimize Relay programs. " alt="" coords="785,155,876,181"/>
<area shape="rect" id="node46" href="include_2tvm_2relay_2op__attr__types_8h.html" title="tvm/relay/op_attr_types.h" alt="" coords="2953,229,3140,256"/>
<area shape="rect" id="node7" href="include_2tvm_2base_8h.html" title="Defines the base data structure. " alt="" coords="1730,976,1795,1003"/>
<area shape="rect" id="node25" href="expr_8h.html" title="The Expr and related elements in DataFlow construction. " alt="" coords="2419,901,2480,928"/>
<area shape="rect" id="node28" href="include_2tvm_2runtime_2util_8h.html" title="Useful runtime util. " alt="" coords="1667,1125,1773,1152"/>
<area shape="rect" id="node14" href="registry_8h.html" title="This file defines the TVM global function registry. " alt="" coords="2009,1051,2143,1077"/>
<area shape="rect" id="node16" href="packed__func_8h.html" title="Type&#45;erased function used across TVM API. " alt="" coords="2131,1125,2245,1152"/>
<area shape="rect" id="node20" href="c__runtime__api_8h.html" title="TVM runtime library. " alt="" coords="2539,1275,2663,1301"/>
<area shape="rect" id="node21" href="runtime_2module_8h.html" title="Runtime container of the functions generated by TVM, This is used to support dynamically link..." alt="" coords="2717,1200,2800,1227"/>
<area shape="rect" id="node23" href="ndarray_8h.html" title="Abstract device memory management API. " alt="" coords="2561,1200,2642,1227"/>
<area shape="rect" id="node24" href="node__base_8h.html" title="Base data structure for Node. " alt="" coords="2080,1200,2184,1227"/>
<area shape="rect" id="node30" href="include_2tvm_2tensor_8h.html" title="Dataflow tensor object. " alt="" coords="2577,677,2652,704"/>
<area shape="rect" id="node33" href="expr__operator_8h.html" title="Common operators defined for Expr. " alt="" coords="2353,752,2476,779"/>
<area shape="rect" id="node34" href="arithmetic_8h.html" title="Algebra and set operations and simplifications. " alt="" coords="2891,827,2989,853"/>
<area shape="rect" id="node36" href="include_2tvm_2relay_2base_8h.html" title="Base classes for the Relay IR. " alt="" coords="854,453,927,480"/>
<area shape="rect" id="node37" href="api__registry_8h.html" title="This file contains utilities related to the TVM&#39;s global function registry. " alt="" coords="1489,528,1623,555"/>
<area shape="rect" id="node39" href="attrs_8h.html" title="TVM attribute module. " alt="" coords="1231,528,1324,555"/>
<area shape="rect" id="node43" href="adt_8h.html" title="Algebraic data types for Relay. " alt="" coords="591,229,710,256"/>
<area shape="rect" id="node44" href="include_2tvm_2relay_2op_8h.html" title="Primitive operator definition. " alt="" coords="951,229,1065,256"/>
<area shape="rect" id="node47" href="schedule_8h.html" title="Define a schedule. " alt="" coords="2896,528,3016,555"/>
<area shape="rect" id="node49" href="build__module_8h.html" title="Functions for compiling ops. " alt="" coords="3210,1051,3358,1077"/>
<area shape="rect" id="node48" href="tensor__intrin_8h.html" title="Tensor intrinsic operations. " alt="" coords="2388,603,2503,629"/>
</map>
</div>
</div>
<p><a href="include_2tvm_2relay_2pass_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1pass_1_1PassContextNode.html">tvm::relay::pass::PassContextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1pass_1_1PassContextNode.html" title="PassContextNode contains the information that a pass can rely on, such as analysis results...">PassContextNode</a> contains the information that a pass can rely on, such as analysis results.  <a href="classtvm_1_1relay_1_1pass_1_1PassContextNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1pass_1_1PassInfoNode.html">tvm::relay::pass::PassInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1pass_1_1PassInfoNode.html" title="PassInfoNode contains meta data that will be used to help optimization and analysis. ">PassInfoNode</a> contains meta data that will be used to help optimization and analysis.  <a href="classtvm_1_1relay_1_1pass_1_1PassInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1pass_1_1PassNode.html">tvm::relay::pass::PassNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1pass_1_1PassNode.html" title="PassNode is the base type of differnt types of optimization passes. It is designed as a pure class an...">PassNode</a> is the base type of differnt types of optimization passes. It is designed as a pure class and implemented by different pass subclasses at different granularity of Relay nodes.  <a href="classtvm_1_1relay_1_1pass_1_1PassNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1pass_1_1Pass.html">tvm::relay::pass::Pass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StructuralHash.html">tvm::relay::StructuralHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashing structure in the style of std::hash.  <a href="structtvm_1_1relay_1_1StructuralHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm.html">tvm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relay"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html">tvm::relay</a></td></tr>
<tr class="memdesc:namespacetvm_1_1relay"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relay: a high level functional IR for TVM. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1pass"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1pass.html">tvm::relay::pass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1656ab092d3cfcb187d1b221a482726d"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1pass.html#a1656ab092d3cfcb187d1b221a482726d">tvm::relay::pass::CreateModulePass</a> (const runtime::TypedPackedFunc&lt; Module(Module, PassContext)&gt; &amp;pass_func, int opt_level, const std::string &amp;name, const tvm::Array&lt; tvm::Expr &gt; &amp;required)</td></tr>
<tr class="separator:a1656ab092d3cfcb187d1b221a482726d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b7bddfd84839eae997dc7f0b56607b"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1pass.html#a52b7bddfd84839eae997dc7f0b56607b">tvm::relay::pass::CreateFunctionPass</a> (const runtime::TypedPackedFunc&lt; Function(Function, PassContext)&gt; &amp;pass_func, int opt_level, const std::string &amp;name, const tvm::Array&lt; tvm::Expr &gt; &amp;required)</td></tr>
<tr class="separator:a52b7bddfd84839eae997dc7f0b56607b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef846d5eeb1a34cb94d6672333105b"><td class="memItemLeft" align="right" valign="top">Pass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1pass.html#a68ef846d5eeb1a34cb94d6672333105b">tvm::relay::pass::CreateSequentialPass</a> (const tvm::Array&lt; Pass &gt; &amp;passes, int opt_level, const std::string &amp;name, const tvm::Array&lt; tvm::Expr &gt; &amp;required, const tvm::Array&lt; tvm::Expr &gt; &amp;disabled)</td></tr>
<tr class="separator:a68ef846d5eeb1a34cb94d6672333105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b9049a14e8505f6ed6a85b0888442e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab2b9049a14e8505f6ed6a85b0888442e">tvm::relay::InferType</a> (const Expr &amp;expr, const Module &amp;mod)</td></tr>
<tr class="memdesc:ab2b9049a14e8505f6ed6a85b0888442e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression.  <a href="namespacetvm_1_1relay.html#ab2b9049a14e8505f6ed6a85b0888442e">More...</a><br /></td></tr>
<tr class="separator:ab2b9049a14e8505f6ed6a85b0888442e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efdc29b690d3c2a6bc432aedaf6b523"><td class="memItemLeft" align="right" valign="top">Function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a8efdc29b690d3c2a6bc432aedaf6b523">tvm::relay::InferType</a> (const Function &amp;f, const Module &amp;mod, const GlobalVar &amp;var)</td></tr>
<tr class="memdesc:a8efdc29b690d3c2a6bc432aedaf6b523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of a function as if it is mapped to var in the mod.  <a href="namespacetvm_1_1relay.html#a8efdc29b690d3c2a6bc432aedaf6b523">More...</a><br /></td></tr>
<tr class="separator:a8efdc29b690d3c2a6bc432aedaf6b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edcabb111b86a0987f3c4c4fa8af68e"><td class="memItemLeft" align="right" valign="top">Kind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0edcabb111b86a0987f3c4c4fa8af68e">tvm::relay::KindCheck</a> (const Type &amp;t, const Module &amp;mod)</td></tr>
<tr class="memdesc:a0edcabb111b86a0987f3c4c4fa8af68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that types are well kinded by applying "kinding rules".  <a href="namespacetvm_1_1relay.html#a0edcabb111b86a0987f3c4c4fa8af68e">More...</a><br /></td></tr>
<tr class="separator:a0edcabb111b86a0987f3c4c4fa8af68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8a41f4d5e1698684fe03446776c799"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ade8a41f4d5e1698684fe03446776c799">tvm::relay::AlphaEqual</a> (const Expr &amp;e1, const Expr &amp;e2)</td></tr>
<tr class="memdesc:ade8a41f4d5e1698684fe03446776c799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions for structural equivalence.  <a href="namespacetvm_1_1relay.html#ade8a41f4d5e1698684fe03446776c799">More...</a><br /></td></tr>
<tr class="separator:ade8a41f4d5e1698684fe03446776c799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e72c6921843a960ac588a8c60253d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a396e72c6921843a960ac588a8c60253d">tvm::relay::AlphaEqual</a> (const Type &amp;t1, const Type &amp;t2)</td></tr>
<tr class="memdesc:a396e72c6921843a960ac588a8c60253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two types for structural equivalence.  <a href="namespacetvm_1_1relay.html#a396e72c6921843a960ac588a8c60253d">More...</a><br /></td></tr>
<tr class="separator:a396e72c6921843a960ac588a8c60253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dde25d981d5b506115dd4dba7f67b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a59dde25d981d5b506115dd4dba7f67b7">tvm::relay::WellFormed</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a59dde25d981d5b506115dd4dba7f67b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once.  <a href="namespacetvm_1_1relay.html#a59dde25d981d5b506115dd4dba7f67b7">More...</a><br /></td></tr>
<tr class="separator:a59dde25d981d5b506115dd4dba7f67b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc32688b446d3574932554f6b8c2df"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; Var &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0bcc32688b446d3574932554f6b8c2df">tvm::relay::BoundVars</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a0bcc32688b446d3574932554f6b8c2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from expression expr.  <a href="namespacetvm_1_1relay.html#a0bcc32688b446d3574932554f6b8c2df">More...</a><br /></td></tr>
<tr class="separator:a0bcc32688b446d3574932554f6b8c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; Var &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af2c5771c67f06c0af32c7b4b4269e73f">tvm::relay::FreeVars</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:af2c5771c67f06c0af32c7b4b4269e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free type parameters from expression expr.  <a href="namespacetvm_1_1relay.html#af2c5771c67f06c0af32c7b4b4269e73f">More...</a><br /></td></tr>
<tr class="separator:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; Var &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6b1e94cf8d97514fe4a9493a0dec1559">tvm::relay::AllVars</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all variables from expression expr.  <a href="namespacetvm_1_1relay.html#a6b1e94cf8d97514fe4a9493a0dec1559">More...</a><br /></td></tr>
<tr class="separator:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c1cf787ee89bbf569ce3e3949c0f9"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; TypeVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af22c1cf787ee89bbf569ce3e3949c0f9">tvm::relay::FreeTypeVars</a> (const Expr &amp;expr, const Module &amp;mod)</td></tr>
<tr class="memdesc:af22c1cf787ee89bbf569ce3e3949c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from expression expr.  <a href="namespacetvm_1_1relay.html#af22c1cf787ee89bbf569ce3e3949c0f9">More...</a><br /></td></tr>
<tr class="separator:af22c1cf787ee89bbf569ce3e3949c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d12dbc2a761993a8687d0128cfcc7"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; TypeVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1b8d12dbc2a761993a8687d0128cfcc7">tvm::relay::FreeTypeVars</a> (const Type &amp;t, const Module &amp;mod)</td></tr>
<tr class="memdesc:a1b8d12dbc2a761993a8687d0128cfcc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from type t.  <a href="namespacetvm_1_1relay.html#a1b8d12dbc2a761993a8687d0128cfcc7">More...</a><br /></td></tr>
<tr class="separator:a1b8d12dbc2a761993a8687d0128cfcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82fe36f44f392afc2f4928fe69c246"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; TypeVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0f82fe36f44f392afc2f4928fe69c246">tvm::relay::BoundTypeVars</a> (const Expr &amp;expr, const Module &amp;mod)</td></tr>
<tr class="memdesc:a0f82fe36f44f392afc2f4928fe69c246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from expression expr.  <a href="namespacetvm_1_1relay.html#a0f82fe36f44f392afc2f4928fe69c246">More...</a><br /></td></tr>
<tr class="separator:a0f82fe36f44f392afc2f4928fe69c246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9f82e989e3a2b34ea453eb4372dafd"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; TypeVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aba9f82e989e3a2b34ea453eb4372dafd">tvm::relay::BoundTypeVars</a> (const Type &amp;t, const Module &amp;mod)</td></tr>
<tr class="memdesc:aba9f82e989e3a2b34ea453eb4372dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from type t.  <a href="namespacetvm_1_1relay.html#aba9f82e989e3a2b34ea453eb4372dafd">More...</a><br /></td></tr>
<tr class="separator:aba9f82e989e3a2b34ea453eb4372dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e422f6ecaa0c8866f8e2e21205d512"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; TypeVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a67e422f6ecaa0c8866f8e2e21205d512">tvm::relay::AllTypeVars</a> (const Expr &amp;expr, const Module &amp;mod)</td></tr>
<tr class="memdesc:a67e422f6ecaa0c8866f8e2e21205d512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in expression expr.  <a href="namespacetvm_1_1relay.html#a67e422f6ecaa0c8866f8e2e21205d512">More...</a><br /></td></tr>
<tr class="separator:a67e422f6ecaa0c8866f8e2e21205d512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d0ab30f64b608f349c1a879a2df67"><td class="memItemLeft" align="right" valign="top">tvm::Array&lt; TypeVar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aaf5d0ab30f64b608f349c1a879a2df67">tvm::relay::AllTypeVars</a> (const Type &amp;t, const Module &amp;mod)</td></tr>
<tr class="memdesc:aaf5d0ab30f64b608f349c1a879a2df67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in type t.  <a href="namespacetvm_1_1relay.html#aaf5d0ab30f64b608f349c1a879a2df67">More...</a><br /></td></tr>
<tr class="separator:aaf5d0ab30f64b608f349c1a879a2df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23a6d66dcae2eb70b3df7f1e2ba5674"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af23a6d66dcae2eb70b3df7f1e2ba5674">tvm::relay::DeadCodeElimination</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:af23a6d66dcae2eb70b3df7f1e2ba5674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove expressions which does not effect the program result.  <a href="namespacetvm_1_1relay.html#af23a6d66dcae2eb70b3df7f1e2ba5674">More...</a><br /></td></tr>
<tr class="separator:af23a6d66dcae2eb70b3df7f1e2ba5674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc50940d727a51be83d381961f7be35"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#affc50940d727a51be83d381961f7be35">tvm::relay::FoldConstant</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:affc50940d727a51be83d381961f7be35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions.  <a href="namespacetvm_1_1relay.html#affc50940d727a51be83d381961f7be35">More...</a><br /></td></tr>
<tr class="separator:affc50940d727a51be83d381961f7be35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e15fd72ed6df857d9e724590c332e0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac3e15fd72ed6df857d9e724590c332e0">tvm::relay::FuseOps</a> (const Expr &amp;expr, int fuse_opt_level)</td></tr>
<tr class="memdesc:ac3e15fd72ed6df857d9e724590c332e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse operations into expr into seperate functions.  <a href="namespacetvm_1_1relay.html#ac3e15fd72ed6df857d9e724590c332e0">More...</a><br /></td></tr>
<tr class="separator:ac3e15fd72ed6df857d9e724590c332e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356667d81a80e25dafc6a831c1a3ddb9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a356667d81a80e25dafc6a831c1a3ddb9">tvm::relay::ForwardRewrite</a> (const Expr &amp;expr, const std::string &amp;rewrite_map_attr_name, std::function&lt; NodeRef(const Call &amp;)&gt; fcontext=nullptr, std::function&lt; Expr(const Expr &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:a356667d81a80e25dafc6a831c1a3ddb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order.  <a href="namespacetvm_1_1relay.html#a356667d81a80e25dafc6a831c1a3ddb9">More...</a><br /></td></tr>
<tr class="separator:a356667d81a80e25dafc6a831c1a3ddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b4af7a7e6c47743f02ccf37325b0c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acd5b4af7a7e6c47743f02ccf37325b0c">tvm::relay::ForwardRewrite</a> (const Expr &amp;expr, const FForwardRewrite &amp;rewrite_func, std::function&lt; NodeRef(const Call &amp;)&gt; fcontext=nullptr, std::function&lt; Expr(const Expr &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:acd5b4af7a7e6c47743f02ccf37325b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order.  <a href="namespacetvm_1_1relay.html#acd5b4af7a7e6c47743f02ccf37325b0c">More...</a><br /></td></tr>
<tr class="separator:acd5b4af7a7e6c47743f02ccf37325b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917e50fbb560a15995e8a617d65d1ab"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7917e50fbb560a15995e8a617d65d1ab">tvm::relay::RewriteAnnotatedOps</a> (const Expr &amp;expr, int fallback_device)</td></tr>
<tr class="memdesc:a7917e50fbb560a15995e8a617d65d1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="namespacetvm_1_1relay.html#a7917e50fbb560a15995e8a617d65d1ab">More...</a><br /></td></tr>
<tr class="separator:a7917e50fbb560a15995e8a617d65d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e35e7086b1f79ae55651500f94116b"><td class="memItemLeft" align="right" valign="top">Map&lt; Expr, Integer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab6e35e7086b1f79ae55651500f94116b">tvm::relay::CollectDeviceInfo</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:ab6e35e7086b1f79ae55651500f94116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the device mapping information of each expression.  <a href="namespacetvm_1_1relay.html#ab6e35e7086b1f79ae55651500f94116b">More...</a><br /></td></tr>
<tr class="separator:ab6e35e7086b1f79ae55651500f94116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b53ca4ace01a21b39912372ffc78f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ace8b53ca4ace01a21b39912372ffc78f">tvm::relay::ToANormalForm</a> (const Expr &amp;e, const Module &amp;mod)</td></tr>
<tr class="memdesc:ace8b53ca4ace01a21b39912372ffc78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF).  <a href="namespacetvm_1_1relay.html#ace8b53ca4ace01a21b39912372ffc78f">More...</a><br /></td></tr>
<tr class="separator:ace8b53ca4ace01a21b39912372ffc78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4041be7958bc78d75f83562bfdb9bd9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae4041be7958bc78d75f83562bfdb9bd9">tvm::relay::ToGraphNormalForm</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ae4041be7958bc78d75f83562bfdb9bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let binding and directly share via pointer instead.  <a href="namespacetvm_1_1relay.html#ae4041be7958bc78d75f83562bfdb9bd9">More...</a><br /></td></tr>
<tr class="separator:ae4041be7958bc78d75f83562bfdb9bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The set of Relay passes written in C++. </p>
<p>Copyright (c) 2018 by Contributors</p>
<p>This file also implements a pass manager. The pass manager manages a sequence of Relay-to-Relay transformation passes over a particlar unit of AST. The design is largely inspired from LLVM's pass manager and modern deep learning frameworks that perform tensor-&gt;tensor transformations.</p>
<p>The responsibilities of a traditional compiler pass manager usually involves:</p><ul>
<li>Organizing the execution order of optimization passes though not necessarily in the optimal sequence.</li>
<li>Collecting required analysis information and keep them up-to-date.</li>
<li>Reducing the effort required to implement new passes for compiler developers, etc.</li>
</ul>
<p>Similar to LLVM's pass manager, we designed the Relay pass manager to work different granularity, i.e. module level, function level, and even sequential passe that contains a host of passes.</p>
<p>However, we also extend the functionality of the traditional pass manager with the consideration of requirements/convention from deep learning frameworks, such as Pytorch and Gluon, etc. Each pass in the Relay pass manager performs the Relay.Module -&gt; Relay.Module transformation. All different types of passes, including the sequential-level pass object, are essentially pass objects. This design, therefore, effectively provides users a consistent and convenient interface, i.e. Pass, to play with. It offers a means to ease the development and testing of Relay passes. For example, with the pass manager, external users will be able to have custom passes correctly scheduled without having to modify a single handcrafted pass order.</p>
<p>In the future we need to describe constraints between passes. For example, we may want to preserve dependencies between different passes and validate them on the completion of a certain pass.</p>
<p>We also need to store side information and import the error reporting system. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 6 2019 11:14:40 for tvm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
