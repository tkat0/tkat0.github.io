<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::ir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1ir.html">ir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::ir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1ir_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1ir_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of possible attribute sin AttrStmt.attr_key <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1ir_1_1intrinsic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir_1_1intrinsic.html">intrinsic</a></td></tr>
<tr class="memdesc:namespacetvm_1_1ir_1_1intrinsic"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of TVM Intrinsic functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1ir_1_1CommReducer.html">CommReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1ir_1_1CommReducerNode.html">CommReducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A commutative reducer node to represent a commutative binary operator with identity element.  <a href="structtvm_1_1ir_1_1CommReducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1ir_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function.  <a href="classtvm_1_1ir_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1ir_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const Expr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1ir_1_1IRMutator.html">IRMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for mutator to iterative mutate the IR  <a href="classtvm_1_1ir_1_1IRMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1ir_1_1IRVisitor.html">IRVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for visitor to iterative traverse the IR  <a href="classtvm_1_1ir_1_1IRVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1ir_1_1Reduce.html">Reduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operator operator.  <a href="structtvm_1_1ir_1_1Reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1ir_1_1StmtFunctor.html">StmtFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classtvm_1_1ir_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> except it is applied on statements.  <a href="classtvm_1_1ir_1_1StmtFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1ir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4.html">StmtFunctor&lt; R(const Stmt &amp;n, Args...args)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1ir_1_1TensorKey.html">TensorKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary data structure used in IR Pass to indicate a tensor.  <a href="structtvm_1_1ir_1_1TensorKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9838bb807ff79fe02c06b73868179427"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a9838bb807ff79fe02c06b73868179427">TypeAnnotation</a> (Type dtype)</td></tr>
<tr class="memdesc:a9838bb807ff79fe02c06b73868179427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type annotation expression.  <a href="#a9838bb807ff79fe02c06b73868179427">More...</a><br /></td></tr>
<tr class="separator:a9838bb807ff79fe02c06b73868179427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd516ee9679e301d2ce7c7a0d98302"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ad4bd516ee9679e301d2ce7c7a0d98302">IRTransform</a> (const Stmt &amp;node, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;preorder, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;postorder, const Array&lt; Expr &gt; &amp;only_enable={})</td></tr>
<tr class="memdesc:ad4bd516ee9679e301d2ce7c7a0d98302"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, and transform it  <a href="#ad4bd516ee9679e301d2ce7c7a0d98302">More...</a><br /></td></tr>
<tr class="separator:ad4bd516ee9679e301d2ce7c7a0d98302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629289297410fbefeec54a1275f04cf1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a629289297410fbefeec54a1275f04cf1">Simplify</a> (Expr expr, Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:a629289297410fbefeec54a1275f04cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the expression.  <a href="#a629289297410fbefeec54a1275f04cf1">More...</a><br /></td></tr>
<tr class="separator:a629289297410fbefeec54a1275f04cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae4366eb55d8b7cfcbf05fdd89c71fd"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#abae4366eb55d8b7cfcbf05fdd89c71fd">Simplify</a> (Stmt stmt, Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:abae4366eb55d8b7cfcbf05fdd89c71fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the statement.  <a href="#abae4366eb55d8b7cfcbf05fdd89c71fd">More...</a><br /></td></tr>
<tr class="separator:abae4366eb55d8b7cfcbf05fdd89c71fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b609b6b4363bfbe187173dd9da860e"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a31b609b6b4363bfbe187173dd9da860e">CanonicalSimplify</a> (Stmt stmt, Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:a31b609b6b4363bfbe187173dd9da860e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify by applying canonical form.  <a href="#a31b609b6b4363bfbe187173dd9da860e">More...</a><br /></td></tr>
<tr class="separator:a31b609b6b4363bfbe187173dd9da860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152f30d820fb32077e6058ebbb8e41fd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a152f30d820fb32077e6058ebbb8e41fd">CanonicalSimplify</a> (Expr expr, Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:a152f30d820fb32077e6058ebbb8e41fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify by applying canonical form.  <a href="#a152f30d820fb32077e6058ebbb8e41fd">More...</a><br /></td></tr>
<tr class="separator:a152f30d820fb32077e6058ebbb8e41fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436450f0ef916d72c284f3d4374562a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a436450f0ef916d72c284f3d4374562a6">Equal</a> (const Expr &amp;lhs, const Expr &amp;rhs)</td></tr>
<tr class="memdesc:a436450f0ef916d72c284f3d4374562a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep compare lhs and rhs.  <a href="#a436450f0ef916d72c284f3d4374562a6">More...</a><br /></td></tr>
<tr class="separator:a436450f0ef916d72c284f3d4374562a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0aae6863e7f9b720ca4fb5da7f0147"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#acc0aae6863e7f9b720ca4fb5da7f0147">Equal</a> (const Stmt &amp;lhs, const Stmt &amp;rhs)</td></tr>
<tr class="memdesc:acc0aae6863e7f9b720ca4fb5da7f0147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep compare lhs and rhs.  <a href="#acc0aae6863e7f9b720ca4fb5da7f0147">More...</a><br /></td></tr>
<tr class="separator:acc0aae6863e7f9b720ca4fb5da7f0147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbe23b7e98d4af784d1d024687b9fd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a2dbe23b7e98d4af784d1d024687b9fd9">Compare</a> (const Expr &amp;lhs, const Expr &amp;rhs)</td></tr>
<tr class="memdesc:a2dbe23b7e98d4af784d1d024687b9fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep compare lhs and rhs.  <a href="#a2dbe23b7e98d4af784d1d024687b9fd9">More...</a><br /></td></tr>
<tr class="separator:a2dbe23b7e98d4af784d1d024687b9fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb399a3a28afc133f6e79ba0dd634b27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#afb399a3a28afc133f6e79ba0dd634b27">VerifySSA</a> (const Stmt &amp;ir)</td></tr>
<tr class="memdesc:afb399a3a28afc133f6e79ba0dd634b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">verifies whether the IR stmt or Expr is in SSA form. That is: each VarExpr is defined and assigned once(in Let/For)  <a href="#afb399a3a28afc133f6e79ba0dd634b27">More...</a><br /></td></tr>
<tr class="separator:afb399a3a28afc133f6e79ba0dd634b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988a22f9083c6d85e0e5490c1571ccd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a988a22f9083c6d85e0e5490c1571ccd0">HasSideEffect</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a988a22f9083c6d85e0e5490c1571ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the expression have side effect.  <a href="#a988a22f9083c6d85e0e5490c1571ccd0">More...</a><br /></td></tr>
<tr class="separator:a988a22f9083c6d85e0e5490c1571ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5bf18ebf31902f630ae2f5716fc37a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a1d5bf18ebf31902f630ae2f5716fc37a">ExprUseVar</a> (const Expr &amp;e, const <a class="el" href="classtvm_1_1Var.html">Var</a> &amp;v)</td></tr>
<tr class="memdesc:a1d5bf18ebf31902f630ae2f5716fc37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether e expression used var.  <a href="#a1d5bf18ebf31902f630ae2f5716fc37a">More...</a><br /></td></tr>
<tr class="separator:a1d5bf18ebf31902f630ae2f5716fc37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8dca335a0aee467064ddab7c1800a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ad1a8dca335a0aee467064ddab7c1800a">ExprUseVar</a> (const Expr &amp;e, const std::unordered_set&lt; const Variable * &gt; &amp;vset)</td></tr>
<tr class="memdesc:ad1a8dca335a0aee467064ddab7c1800a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether e expression used any var in variable set..  <a href="#ad1a8dca335a0aee467064ddab7c1800a">More...</a><br /></td></tr>
<tr class="separator:ad1a8dca335a0aee467064ddab7c1800a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b45a97d9322ccbdf77eebf805ef58f"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a41b45a97d9322ccbdf77eebf805ef58f">ConvertSSA</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a41b45a97d9322ccbdf77eebf805ef58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a IR node to be SSA form.  <a href="#a41b45a97d9322ccbdf77eebf805ef58f">More...</a><br /></td></tr>
<tr class="separator:a41b45a97d9322ccbdf77eebf805ef58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02245d38283448a58a3f828467c3412d"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a02245d38283448a58a3f828467c3412d">Substitute</a> (Stmt stmt, const std::unordered_map&lt; const Variable *, Expr &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a02245d38283448a58a3f828467c3412d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#a02245d38283448a58a3f828467c3412d">More...</a><br /></td></tr>
<tr class="separator:a02245d38283448a58a3f828467c3412d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8fe2b5a27086796ba765fddaa868e3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a6a8fe2b5a27086796ba765fddaa868e3">Substitute</a> (Expr expr, const std::unordered_map&lt; const Variable *, Expr &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a6a8fe2b5a27086796ba765fddaa868e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#a6a8fe2b5a27086796ba765fddaa868e3">More...</a><br /></td></tr>
<tr class="separator:a6a8fe2b5a27086796ba765fddaa868e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5c59967cc16ce2ad6aca3917a670e4"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#aec5c59967cc16ce2ad6aca3917a670e4">Substitute</a> (Stmt stmt, const Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, Expr &gt; &amp;value_map)</td></tr>
<tr class="memdesc:aec5c59967cc16ce2ad6aca3917a670e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#aec5c59967cc16ce2ad6aca3917a670e4">More...</a><br /></td></tr>
<tr class="separator:aec5c59967cc16ce2ad6aca3917a670e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f527afe77a90ceb5b575de931c62c6c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a0f527afe77a90ceb5b575de931c62c6c">Substitute</a> (Expr expr, const Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, Expr &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a0f527afe77a90ceb5b575de931c62c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#a0f527afe77a90ceb5b575de931c62c6c">More...</a><br /></td></tr>
<tr class="separator:a0f527afe77a90ceb5b575de931c62c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e5aed82c6d5d0623d503ff34e403e"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#af05e5aed82c6d5d0623d503ff34e403e">Inline</a> (Stmt stmt, FunctionRef f, Array&lt; <a class="el" href="classtvm_1_1Var.html">Var</a> &gt; args, Expr body)</td></tr>
<tr class="memdesc:af05e5aed82c6d5d0623d503ff34e403e"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline all calls of f in stmt.  <a href="#af05e5aed82c6d5d0623d503ff34e403e">More...</a><br /></td></tr>
<tr class="separator:af05e5aed82c6d5d0623d503ff34e403e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3084acce1f424a348dbe74f8c3b3ed0"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#af3084acce1f424a348dbe74f8c3b3ed0">StorageFlatten</a> (Stmt stmt, Map&lt; <a class="el" href="classtvm_1_1Tensor.html">Tensor</a>, <a class="el" href="classtvm_1_1Buffer.html">Buffer</a> &gt; extern_buffer, int cache_line_size, bool create_bound_attribute=false)</td></tr>
<tr class="memdesc:af3084acce1f424a348dbe74f8c3b3ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the multi-dimensional read/write to single dimensional Load/Store.  <a href="#af3084acce1f424a348dbe74f8c3b3ed0">More...</a><br /></td></tr>
<tr class="separator:af3084acce1f424a348dbe74f8c3b3ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb3c830a29c124f29fade0f77a0a03c"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a1bb3c830a29c124f29fade0f77a0a03c">RemoveNoOp</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a1bb3c830a29c124f29fade0f77a0a03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove No Op from the Stmt.  <a href="#a1bb3c830a29c124f29fade0f77a0a03c">More...</a><br /></td></tr>
<tr class="separator:a1bb3c830a29c124f29fade0f77a0a03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dcbd7eb9bdc102bce5a6accb552bd2"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a05dcbd7eb9bdc102bce5a6accb552bd2">SplitPipeline</a> (Stmt stmt, bool split_load)</td></tr>
<tr class="memdesc:a05dcbd7eb9bdc102bce5a6accb552bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split statement into pipeine stages.  <a href="#a05dcbd7eb9bdc102bce5a6accb552bd2">More...</a><br /></td></tr>
<tr class="separator:a05dcbd7eb9bdc102bce5a6accb552bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab178245ababb33d6d42b55b1def528c0"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ab178245ababb33d6d42b55b1def528c0">NarrowChannelAccess</a> (Stmt stmt)</td></tr>
<tr class="memdesc:ab178245ababb33d6d42b55b1def528c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow channel access to smaller range.  <a href="#ab178245ababb33d6d42b55b1def528c0">More...</a><br /></td></tr>
<tr class="separator:ab178245ababb33d6d42b55b1def528c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9e072f69954fcae8ff415fbd831bc"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#af9e9e072f69954fcae8ff415fbd831bc">UnrollLoop</a> (Stmt stmt, int auto_max_step, int auto_max_depth, int auto_max_extent, bool explicit_unroll)</td></tr>
<tr class="memdesc:af9e9e072f69954fcae8ff415fbd831bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard.  <a href="#af9e9e072f69954fcae8ff415fbd831bc">More...</a><br /></td></tr>
<tr class="separator:af9e9e072f69954fcae8ff415fbd831bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de1e80083904ad7e5fdd9ed25bde36b"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a4de1e80083904ad7e5fdd9ed25bde36b">VectorizeLoop</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a4de1e80083904ad7e5fdd9ed25bde36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vectorize the constant loops  <a href="#a4de1e80083904ad7e5fdd9ed25bde36b">More...</a><br /></td></tr>
<tr class="separator:a4de1e80083904ad7e5fdd9ed25bde36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea27143098746be8225cd973762b06f"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a9ea27143098746be8225cd973762b06f">InstrumentBoundCheckers</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a9ea27143098746be8225cd973762b06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">instruments bound checkers.  <a href="#a9ea27143098746be8225cd973762b06f">More...</a><br /></td></tr>
<tr class="separator:a9ea27143098746be8225cd973762b06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b05af3fcf06ece893471e99c166f2e"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a81b05af3fcf06ece893471e99c166f2e">InjectVirtualThread</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a81b05af3fcf06ece893471e99c166f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject virtual thread loops into stmt.  <a href="#a81b05af3fcf06ece893471e99c166f2e">More...</a><br /></td></tr>
<tr class="separator:a81b05af3fcf06ece893471e99c166f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2270897a7a383231a2b4c30b898f1107"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a2270897a7a383231a2b4c30b898f1107">InjectPrefetch</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a2270897a7a383231a2b4c30b898f1107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject prefetch instructions into stmt.  <a href="#a2270897a7a383231a2b4c30b898f1107">More...</a><br /></td></tr>
<tr class="separator:a2270897a7a383231a2b4c30b898f1107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca579c0c652c41bcfa00f3f3d480fb9"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a0ca579c0c652c41bcfa00f3f3d480fb9">InjectDoubleBuffer</a> (Stmt stmt, int split_loop)</td></tr>
<tr class="memdesc:a0ca579c0c652c41bcfa00f3f3d480fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject double buffer into stmt.  <a href="#a0ca579c0c652c41bcfa00f3f3d480fb9">More...</a><br /></td></tr>
<tr class="separator:a0ca579c0c652c41bcfa00f3f3d480fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710742ce27bd11535211bd2f1af1beb"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a2710742ce27bd11535211bd2f1af1beb">InjectCopyIntrin</a> (Stmt stmt, const std::string &amp;pragma_key, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;fintrin)</td></tr>
<tr class="memdesc:a2710742ce27bd11535211bd2f1af1beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject copy intrinsics with optional pad.  <a href="#a2710742ce27bd11535211bd2f1af1beb">More...</a><br /></td></tr>
<tr class="separator:a2710742ce27bd11535211bd2f1af1beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47642d998cb485a4335747074ebe101d"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a47642d998cb485a4335747074ebe101d">StorageRewrite</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a47642d998cb485a4335747074ebe101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible.  <a href="#a47642d998cb485a4335747074ebe101d">More...</a><br /></td></tr>
<tr class="separator:a47642d998cb485a4335747074ebe101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085d5ed240a6fba532dd2d2c67d2bc67"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a085d5ed240a6fba532dd2d2c67d2bc67">LoopPartition</a> (Stmt stmt, bool split_const_loop)</td></tr>
<tr class="memdesc:a085d5ed240a6fba532dd2d2c67d2bc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition loops in the stmt  <a href="#a085d5ed240a6fba532dd2d2c67d2bc67">More...</a><br /></td></tr>
<tr class="separator:a085d5ed240a6fba532dd2d2c67d2bc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e572636dd782e92430d8e64cac419e"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ae6e572636dd782e92430d8e64cac419e">CoProcSync</a> (Stmt stmt)</td></tr>
<tr class="memdesc:ae6e572636dd782e92430d8e64cac419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and insert sync points to co-processor.  <a href="#ae6e572636dd782e92430d8e64cac419e">More...</a><br /></td></tr>
<tr class="separator:ae6e572636dd782e92430d8e64cac419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a40e5541650de1166c8dbbce4b47ce5"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a1a40e5541650de1166c8dbbce4b47ce5">LiftAttrScope</a> (Stmt stmt, std::string attr_key)</td></tr>
<tr class="memdesc:a1a40e5541650de1166c8dbbce4b47ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift common attrs with attr_key to outer scope.  <a href="#a1a40e5541650de1166c8dbbce4b47ce5">More...</a><br /></td></tr>
<tr class="separator:a1a40e5541650de1166c8dbbce4b47ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c284e467afef79aed5ec5b7a3fab0d"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a71c284e467afef79aed5ec5b7a3fab0d">RewriteUnsafeSelect</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a71c284e467afef79aed5ec5b7a3fab0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and rewrite unsafe select that contains memory access.  <a href="#a71c284e467afef79aed5ec5b7a3fab0d">More...</a><br /></td></tr>
<tr class="separator:a71c284e467afef79aed5ec5b7a3fab0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b5df614e4559e97302769b9d7062f5"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a47b5df614e4559e97302769b9d7062f5">LowerStorageAccessInfo</a> (Stmt stmt)</td></tr>
<tr class="memdesc:a47b5df614e4559e97302769b9d7062f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower attached storage access information. Do this pass after all storage access analysis finish.  <a href="#a47b5df614e4559e97302769b9d7062f5">More...</a><br /></td></tr>
<tr class="separator:a47b5df614e4559e97302769b9d7062f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17922d9ea77888257faaa780e7dd4ba"><td class="memItemLeft" align="right" valign="top">Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ac17922d9ea77888257faaa780e7dd4ba">DecorateDeviceScope</a> (Stmt stmt)</td></tr>
<tr class="memdesc:ac17922d9ea77888257faaa780e7dd4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks.  <a href="#ac17922d9ea77888257faaa780e7dd4ba">More...</a><br /></td></tr>
<tr class="separator:ac17922d9ea77888257faaa780e7dd4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e65239879517d9e06354a77318732c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a17e65239879517d9e06354a77318732c">MakeAPI</a> (Stmt body, std::string name, Array&lt; NodeRef &gt; api_args, int num_unpacked_args, bool is_restricted)</td></tr>
<tr class="memdesc:a17e65239879517d9e06354a77318732c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an user callable API <a class="el" href="classtvm_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a>.  <a href="#a17e65239879517d9e06354a77318732c">More...</a><br /></td></tr>
<tr class="separator:a17e65239879517d9e06354a77318732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee43fd577407ab23bfa7f918734a24a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a6ee43fd577407ab23bfa7f918734a24a">BindDeviceType</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> func, int device_type)</td></tr>
<tr class="memdesc:a6ee43fd577407ab23bfa7f918734a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the device type of host function to be device_type.  <a href="#a6ee43fd577407ab23bfa7f918734a24a">More...</a><br /></td></tr>
<tr class="separator:a6ee43fd577407ab23bfa7f918734a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc807d7b1ecc0c27fd9b5deb1bc7a9ec"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#afc807d7b1ecc0c27fd9b5deb1bc7a9ec">UndefinedVars</a> (const Stmt &amp;stmt, const Array&lt; <a class="el" href="classtvm_1_1Var.html">Var</a> &gt; &amp;defs)</td></tr>
<tr class="memdesc:afc807d7b1ecc0c27fd9b5deb1bc7a9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the statment.  <a href="#afc807d7b1ecc0c27fd9b5deb1bc7a9ec">More...</a><br /></td></tr>
<tr class="separator:afc807d7b1ecc0c27fd9b5deb1bc7a9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dd469ba4d32670492dad54dd489422"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a81dd469ba4d32670492dad54dd489422">SplitHostDevice</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> func)</td></tr>
<tr class="memdesc:a81dd469ba4d32670492dad54dd489422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the function into a host function and device functions.  <a href="#a81dd469ba4d32670492dad54dd489422">More...</a><br /></td></tr>
<tr class="separator:a81dd469ba4d32670492dad54dd489422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2df43b631be563d2cf9b39e66c9fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a4b2df43b631be563d2cf9b39e66c9fc0">ThreadSync</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> stmt, std::string storage_scope)</td></tr>
<tr class="memdesc:a4b2df43b631be563d2cf9b39e66c9fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert sync between parallel read/write of shared buffers.  <a href="#a4b2df43b631be563d2cf9b39e66c9fc0">More...</a><br /></td></tr>
<tr class="separator:a4b2df43b631be563d2cf9b39e66c9fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86861342a62ce2dd0e387cd102d89dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a86861342a62ce2dd0e387cd102d89dfb">LowerThreadAllreduce</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f, int warp_size)</td></tr>
<tr class="memdesc:a86861342a62ce2dd0e387cd102d89dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross thread alleduce in the stmt.  <a href="#a86861342a62ce2dd0e387cd102d89dfb">More...</a><br /></td></tr>
<tr class="separator:a86861342a62ce2dd0e387cd102d89dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f14ff05b55dfb2bf1ead924dd036726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a1f14ff05b55dfb2bf1ead924dd036726">LowerWarpMemory</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f, int warp_size)</td></tr>
<tr class="memdesc:a1f14ff05b55dfb2bf1ead924dd036726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower warp memory in stmt.  <a href="#a1f14ff05b55dfb2bf1ead924dd036726">More...</a><br /></td></tr>
<tr class="separator:a1f14ff05b55dfb2bf1ead924dd036726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f8beedce3f24d68c0e689a6299d372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a00f8beedce3f24d68c0e689a6299d372">RemapThreadAxis</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f, Map&lt; Expr, <a class="el" href="classtvm_1_1IterVar.html">IterVar</a> &gt; axis_map)</td></tr>
<tr class="memdesc:a00f8beedce3f24d68c0e689a6299d372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap the thread axis.  <a href="#a00f8beedce3f24d68c0e689a6299d372">More...</a><br /></td></tr>
<tr class="separator:a00f8beedce3f24d68c0e689a6299d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09adb682ee2aa316c40789f7833b138d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a09adb682ee2aa316c40789f7833b138d">LowerTVMBuiltin</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:a09adb682ee2aa316c40789f7833b138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower packed function call.  <a href="#a09adb682ee2aa316c40789f7833b138d">More...</a><br /></td></tr>
<tr class="separator:a09adb682ee2aa316c40789f7833b138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2f2a3bf05978ee97369bb38dbdcfff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a1f2f2a3bf05978ee97369bb38dbdcfff">CombineContextCall</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:a1f2f2a3bf05978ee97369bb38dbdcfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine context function calls.  <a href="#a1f2f2a3bf05978ee97369bb38dbdcfff">More...</a><br /></td></tr>
<tr class="separator:a1f2f2a3bf05978ee97369bb38dbdcfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0754e4b0f3fbab6537d0f67d4774f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#abd0754e4b0f3fbab6537d0f67d4774f0">PointerValueTypeRewrite</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:abd0754e4b0f3fbab6537d0f67d4774f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible.  <a href="#abd0754e4b0f3fbab6537d0f67d4774f0">More...</a><br /></td></tr>
<tr class="separator:abd0754e4b0f3fbab6537d0f67d4774f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36184de564c97d31379ab4820c0e07fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#a36184de564c97d31379ab4820c0e07fc">LowerIntrin</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> f, const std::string &amp;target)</td></tr>
<tr class="memdesc:a36184de564c97d31379ab4820c0e07fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower intrinsic function calls.  <a href="#a36184de564c97d31379ab4820c0e07fc">More...</a><br /></td></tr>
<tr class="separator:a36184de564c97d31379ab4820c0e07fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa611c94bdcf8ba3b41ebb83341a54250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#aa611c94bdcf8ba3b41ebb83341a54250">VerifyMemory</a> (<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> func, int device_type)</td></tr>
<tr class="memdesc:aa611c94bdcf8ba3b41ebb83341a54250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if memory accesses are legal for a specific target device type.  <a href="#aa611c94bdcf8ba3b41ebb83341a54250">More...</a><br /></td></tr>
<tr class="separator:aa611c94bdcf8ba3b41ebb83341a54250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e138dd58a09ee69e6f94fca1687c12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ae1e138dd58a09ee69e6f94fca1687c12">VerifyGPUCode</a> (Stmt stmt, Map&lt; std::string, Expr &gt; constraints)</td></tr>
<tr class="memdesc:ae1e138dd58a09ee69e6f94fca1687c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit.  <a href="#ae1e138dd58a09ee69e6f94fca1687c12">More...</a><br /></td></tr>
<tr class="separator:ae1e138dd58a09ee69e6f94fca1687c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66ea68d72c1161a65aa2743402b584b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1ir.html#ad66ea68d72c1161a65aa2743402b584b">PostOrderVisit</a> (const NodeRef &amp;node, std::function&lt; void(const NodeRef &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:ad66ea68d72c1161a65aa2743402b584b"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#ad66ea68d72c1161a65aa2743402b584b">More...</a><br /></td></tr>
<tr class="separator:ad66ea68d72c1161a65aa2743402b584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6ee43fd577407ab23bfa7f918734a24a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::BindDeviceType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the device type of host function to be device_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be binded. </td></tr>
    <tr><td class="paramname">device_type</td><td>The device type to be binded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binded function. </dd></dl>

</div>
</div>
<a class="anchor" id="a31b609b6b4363bfbe187173dd9da860e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::CanonicalSimplify </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code>Map&lt;&#160;<a class="el" href="classtvm_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify by applying canonical form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be canonically simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized statement. </dd></dl>

</div>
</div>
<a class="anchor" id="a152f30d820fb32077e6058ebbb8e41fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Expr tvm::ir::CanonicalSimplify </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code>Map&lt;&#160;<a class="el" href="classtvm_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify by applying canonical form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The statement to be canonically simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f2f2a3bf05978ee97369bb38dbdcfff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::CombineContextCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine context function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The host function to be lowered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dbe23b7e98d4af784d1d024687b9fd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::ir::Compare </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep compare lhs and rhs. </p>
<p>If you only want equality comparison, use Equal which will also tie definitions. The compare mode will give order of expression in total order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result. </dd></dl>

</div>
</div>
<a class="anchor" id="a41b45a97d9322ccbdf77eebf805ef58f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::ConvertSSA </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a IR node to be SSA form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6e572636dd782e92430d8e64cac419e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::CoProcSync </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and insert sync points to co-processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ac17922d9ea77888257faaa780e7dd4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::DecorateDeviceScope </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a436450f0ef916d72c284f3d4374562a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::Equal </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep compare lhs and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result. </dd></dl>

</div>
</div>
<a class="anchor" id="acc0aae6863e7f9b720ca4fb5da7f0147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::Equal </td>
          <td>(</td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep compare lhs and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d5bf18ebf31902f630ae2f5716fc37a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::ExprUseVar </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether e expression used var. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">v</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether e uses v. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1a8dca335a0aee467064ddab7c1800a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::ExprUseVar </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; const Variable * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether e expression used any var in variable set.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">vset</td><td>The variable set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether e uses vset. </dd></dl>

</div>
</div>
<a class="anchor" id="a988a22f9083c6d85e0e5490c1571ccd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::HasSideEffect </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the expression have side effect. </p>
<dl class="section return"><dt>Returns</dt><dd>whether expression have side effect </dd></dl>

</div>
</div>
<a class="anchor" id="a2710742ce27bd11535211bd2f1af1beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::InjectCopyIntrin </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pragma_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>fintrin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject copy intrinsics with optional pad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be transformed. </td></tr>
    <tr><td class="paramname">pragma_key</td><td>The pragma key for hint of copy. </td></tr>
    <tr><td class="paramname">fintrin</td><td>The function with signature</td></tr>
  </table>
  </dd>
</dl>
<p>Stmt fintrin(<a class="el" href="classtvm_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> src, <a class="el" href="classtvm_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> dst, Array&lt;Expr&gt; pad_before, Array&lt;Expr&gt; pad_after, Expr pad_value) </p><dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ca579c0c652c41bcfa00f3f3d480fb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::InjectDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split_loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject double buffer into stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be transformed. </td></tr>
    <tr><td class="paramname">split_loop</td><td>Loop splitting factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a2270897a7a383231a2b4c30b898f1107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::InjectPrefetch </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject prefetch instructions into stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a81b05af3fcf06ece893471e99c166f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::InjectVirtualThread </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject virtual thread loops into stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="af05e5aed82c6d5d0623d503ff34e403e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::Inline </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionRef&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; <a class="el" href="classtvm_1_1Var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inline all calls of f in stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to apply inline optimization. </td></tr>
    <tr><td class="paramname">f</td><td>The function reference to be inlined </td></tr>
    <tr><td class="paramname">args</td><td>The arguments variable of the function. </td></tr>
    <tr><td class="paramname">body</td><td>The definition body of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result stmt</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All the passes in this file uses SSA form and outputs SSA form. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea27143098746be8225cd973762b06f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::InstrumentBoundCheckers </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>instruments bound checkers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be instrumented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instrumented Stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4bd516ee9679e301d2ce7c7a0d98302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::IRTransform </td>
          <td>(</td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>postorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>only_enable</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, and transform it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be transformed. </td></tr>
    <tr><td class="paramname">preorder</td><td>The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/Expr, the transformer will simply return it and won't do further recursion. </td></tr>
    <tr><td class="paramname">postorder</td><td>The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. </td></tr>
    <tr><td class="paramname">only_enable</td><td>List of StringImm. If it is empty, all IRNode will call preorder/postorder If it is not empty, preorder/postorder will only be called when the IRNode's type key is in the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a40e5541650de1166c8dbbce4b47ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::LiftAttrScope </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attr_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lift common attrs with attr_key to outer scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
    <tr><td class="paramname">attr_key</td><td>The attribute key to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a085d5ed240a6fba532dd2d2c67d2bc67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::LoopPartition </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>split_const_loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>partition loops in the stmt </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to do loop partition </td></tr>
    <tr><td class="paramname">split_const_loop</td><td>flag to enable partition for const loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a36184de564c97d31379ab4820c0e07fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::LowerIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower intrinsic function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">target</td><td>The target device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a47b5df614e4559e97302769b9d7062f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::LowerStorageAccessInfo </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower attached storage access information. Do this pass after all storage access analysis finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a86861342a62ce2dd0e387cd102d89dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::LowerThreadAllreduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>warp_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross thread alleduce in the stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">warp_size</td><td>the size of warp where no sync is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a09adb682ee2aa316c40789f7833b138d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::LowerTVMBuiltin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower packed function call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be lowered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f14ff05b55dfb2bf1ead924dd036726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::LowerWarpMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>warp_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower warp memory in stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">warp_size</td><td>the size of warp where no sync is needed. this function will only take in effect if warp_size is bigger than one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a17e65239879517d9e06354a77318732c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::MakeAPI </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; NodeRef &gt;&#160;</td>
          <td class="paramname"><em>api_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_unpacked_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_restricted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an user callable API <a class="el" href="classtvm_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a>. </p>
<p>The main task of this function is to create code to :</p><ul>
<li>Map the values in the api_args to of <a class="el" href="classtvm_1_1Var.html" title="a named variable in TVM ">Var</a> that is required by body.</li>
<li>Insert assertions to check type/value of the passed arguments.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The body of the function. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the function. </td></tr>
    <tr><td class="paramname">api_args</td><td>Arguments to the function, can be either <a class="el" href="classtvm_1_1Var.html" title="a named variable in TVM ">Var</a>, or <a class="el" href="classtvm_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> </td></tr>
    <tr><td class="paramname">num_unpacked_args</td><td>Number of arguments that are processed in plain form instead of packed form. </td></tr>
    <tr><td class="paramname">is_restricted</td><td>Whether the caller can guarantee that each buffer argument do not overlap. It is recommended to set to true for optimized code if such invariant holds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtvm_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a> with the specified signiture.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function signiture have two cases</dd></dl>
<p>let num_packed_args = len(api_args) - num_unpacked_args;</p>
<p>if num_packed_args is zero: f(api_arg_0, api_arg_1, .., api_arg_n) where n == len(api_args)</p>
<p>if num_packed_args is not zero: f(TVMArg* packed_args, int* packed_arg_type_ids, int num_packed_args, api_arg_k, api_arg_k+1, ... api_arg_n)</p>
<p>where n == len(api_args), k == num_packed_args</p>
<p>There is no thread_axis in generated function. </p>

</div>
</div>
<a class="anchor" id="ab178245ababb33d6d42b55b1def528c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::NarrowChannelAccess </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow channel access to smaller range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to do access rewriting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="abd0754e4b0f3fbab6537d0f67d4774f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::PointerValueTypeRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </p>
<dl class="section note"><dt>Note</dt><dd>implemeneted in storage_rewrite.cc </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="ad66ea68d72c1161a65aa2743402b584b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::ir::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const NodeRef &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const NodeRef &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00f8beedce3f24d68c0e689a6299d372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::RemapThreadAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; Expr, <a class="el" href="classtvm_1_1IterVar.html">IterVar</a> &gt;&#160;</td>
          <td class="paramname"><em>axis_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap the thread axis. </p>
<p>This can be used to get equivalent program which uses threadIdx.y in place of threadIdx.x by passing {"threadIdx.x": thread_axis("threadIdx.y")}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">axis_map</td><td>The map from StringImm -&gt; ItrVar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bb3c830a29c124f29fade0f77a0a03c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::RemoveNoOp </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove No Op from the Stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a71c284e467afef79aed5ec5b7a3fab0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::RewriteUnsafeSelect </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and rewrite unsafe select that contains memory access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be rewritten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a629289297410fbefeec54a1275f04cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Expr tvm::ir::Simplify </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code>Map&lt;&#160;<a class="el" href="classtvm_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized statement. </dd></dl>

</div>
</div>
<a class="anchor" id="abae4366eb55d8b7cfcbf05fdd89c71fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::Simplify </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code>Map&lt;&#160;<a class="el" href="classtvm_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized statement. </dd></dl>

</div>
</div>
<a class="anchor" id="a81dd469ba4d32670492dad54dd489422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&gt; tvm::ir::SplitHostDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the function into a host function and device functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be splitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of functions, the first one is host function, the others are device functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a05dcbd7eb9bdc102bce5a6accb552bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::SplitPipeline </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>split_load</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split statement into pipeine stages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be splitted </td></tr>
    <tr><td class="paramname">split_load</td><td>Whether split load into its own stage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="af3084acce1f424a348dbe74f8c3b3ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::StorageFlatten </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; <a class="el" href="classtvm_1_1Tensor.html">Tensor</a>, <a class="el" href="classtvm_1_1Buffer.html">Buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>extern_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache_line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_bound_attribute</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the multi-dimensional read/write to single dimensional Load/Store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed. </td></tr>
    <tr><td class="paramname">extern_buffer</td><td>Map specifies external buffer assignment of input and outputs. </td></tr>
    <tr><td class="paramname">cache_line_size</td><td>The size of CPU cache line. </td></tr>
    <tr><td class="paramname">create_bound_attribute</td><td>Whether to create bound attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a47642d998cb485a4335747074ebe101d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::StorageRewrite </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a02245d38283448a58a3f828467c3412d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const Variable *, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a8fe2b5a27086796ba765fddaa868e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Expr tvm::ir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const Variable *, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source expression to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aec5c59967cc16ce2ad6aca3917a670e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f527afe77a90ceb5b575de931c62c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Expr tvm::ir::Substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Map&lt; <a class="el" href="classtvm_1_1Var.html">Var</a>, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source expression to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2df43b631be563d2cf9b39e66c9fc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a> tvm::ir::ThreadSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert sync between parallel read/write of shared buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope considered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9838bb807ff79fe02c06b73868179427"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Expr tvm::ir::TypeAnnotation </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a type annotation expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expr a expression with dtype. </dd></dl>

</div>
</div>
<a class="anchor" id="afc807d7b1ecc0c27fd9b5deb1bc7a9ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1Var.html">Var</a>&gt; tvm::ir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>defs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the statment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The function to be checked. </td></tr>
    <tr><td class="paramname">defs</td><td>The vars that is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a class="anchor" id="af9e9e072f69954fcae8ff415fbd831bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::UnrollLoop </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auto_max_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auto_max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auto_max_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicit_unroll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be unrolled. </td></tr>
    <tr><td class="paramname">auto_max_step</td><td>The maximum step before stop attach automatic unroll </td></tr>
    <tr><td class="paramname">auto_max_depth</td><td>The maximum depth before stop attach automatic unroll </td></tr>
    <tr><td class="paramname">auto_max_extent</td><td>The maximum extent of the loop we can unroll, this is an legacy option that do not take the loop total steps into account. </td></tr>
    <tr><td class="paramname">explicit_unroll</td><td>Whether explicitly unroll the loop, or leave unroll annotation to codegen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a4de1e80083904ad7e5fdd9ed25bde36b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stmt tvm::ir::VectorizeLoop </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vectorize the constant loops </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be vectorized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1e138dd58a09ee69e6f94fca1687c12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::VerifyGPUCode </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; std::string, Expr &gt;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be checked </td></tr>
    <tr><td class="paramname">constraints</td><td>The dict to specify constraints to check. Possible keys are</td></tr>
  </table>
  </dd>
</dl>
<p>"max_local_memory_per_block": Total amount of local memory per block (in bytes). "max_shared_memory_per_block": Total amount of shared memory per block (in bytes). "max_threads_per_block": Maximum number of threads per block. "max_thread_x": Maximum length of threadIdx.x. "max_thread_y": Maximum length of threadIdx.y. "max_thread_z": Maximum length of threadIdx.z.</p>
<p>If one key is missing in this argument, the pass won't check for that item. </p><dl class="section return"><dt>Returns</dt><dd>valid Whether it is a valid GPU code </dd></dl>

</div>
</div>
<a class="anchor" id="aa611c94bdcf8ba3b41ebb83341a54250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::VerifyMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if memory accesses are legal for a specific target device type. </p>
<p>In the case that tgt is cuda, if not all workload is bound with threads, CPU code is generated that tries to access GPU memory, which is illegal. This pass performs verification for this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
    <tr><td class="paramname">device_type</td><td>The target device type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of memory verification. </dd></dl>

</div>
</div>
<a class="anchor" id="afb399a3a28afc133f6e79ba0dd634b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::ir::VerifySSA </td>
          <td>(</td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname"><em>ir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>verifies whether the IR stmt or Expr is in SSA form. That is: each VarExpr is defined and assigned once(in Let/For) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ir</td><td>The root of the IR DAG. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether IR is in SSA form. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All the passes in this file uses SSA form and outputs SSA form. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 6 2019 11:14:41 for tvm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
