

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction to TOPI &mdash; tvm 0.6.dev documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/tvm_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="VTA: Deep Learning Accelerator Stack" href="../../vta/index.html" />
    <link rel="prev" title="Writing a Customized Pass" href="../dev/low_level_custom_pass.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.6.dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../relay_quick_start.html">Quick Start Tutorial for Compiling Deep Learning Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cross_compilation_and_rpc.html">Cross Compilation and RPC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tensor_expr_get_started.html">Get Started with Tensor Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#compile-deep-learning-models">Compile Deep Learning Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#tensor-expression-and-schedules">Tensor Expression and Schedules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#optimize-tensor-operators">Optimize Tensor Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#auto-tuning">Auto tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#developer-tutorials">Developer Tutorials</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#topi-tvm-operator-inventory">TOPI: TVM Operator Inventory</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Introduction to TOPI</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-example">Basic example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#numpy-style-operator-overloading">Numpy-style operator overloading</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-schedules-and-fusing-operations">Generic schedules and fusing operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fusing-convolutions">Fusing convolutions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../vta/index.html">VTA: Deep Learning Accelerator Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deploy/index.html">Deploy and Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribute to TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../langref/index.html">Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/python/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_links.html">Links to API References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/index.html">Design and Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nnvm_top.html">NNVM Core Tensor Operators</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">tvm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Tutorials</a> &raquo;</li>
        
      <li>Introduction to TOPI</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/tutorials/topi/intro_topi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Click <a class="reference internal" href="#sphx-glr-download-tutorials-topi-intro-topi-py"><span class="std std-ref">here</span></a> to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="introduction-to-topi">
<span id="sphx-glr-tutorials-topi-intro-topi-py"></span><h1>Introduction to TOPI<a class="headerlink" href="#introduction-to-topi" title="Permalink to this headline">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="https://github.com/ehsanmok">Ehsan M. Kermani</a></p>
<p>This is an introductory tutorial to TVM Operator Inventory (TOPI).
TOPI provides numpy-style generic operations and schedules with higher abstractions than TVM.
In this tutorial, we will see how TOPI can save us from writing boilerplates code in TVM.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">tvm</span>
<span class="kn">import</span> <span class="nn">topi</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="section" id="basic-example">
<h2>Basic example<a class="headerlink" href="#basic-example" title="Permalink to this headline">¶</a></h2>
<p>Let’s revisit the sum of rows operation (equivalent to <code class="code docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">numpy.sum(A,</span> <span class="pre">axis=1)</span></code>’) To compute the sum of rows of a two dimensional TVM tensor A, we should
specify the symbolic operation as well as schedule as follows</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">reduce_axis</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">compute</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>and to examine the IR code in human readable format, we can do</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">tvm</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="n">simple_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>// attr [B] storage_scope = &quot;global&quot;
allocate B[float32 * n]
produce B {
  for (i, 0, n) {
    B[i] = 0.000000f
    for (k, 0, m) {
      B[i] = (B[i] + A[((i*m) + k)])
    }
  }
}
</pre></div>
</div>
<p>However, for such a common operation we had to define the reduce axis ourselves as well as explicit computation with
:code: <cite>tvm.compute</cite>. Imagine for more complicated operations how much details we need to provide.
Fortunately, we can replace those two lines with simple <code class="code docutils literal notranslate"><span class="pre">topi.sum</span></code> much like :code`numpy.sum`</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">tvm</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="n">simple_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>// attr [A_red] storage_scope = &quot;global&quot;
allocate A_red[float32 * n]
produce A_red {
  for (ax0, 0, n) {
    A_red[ax0] = 0.000000f
    for (k1, 0, m) {
      A_red[ax0] = (A_red[ax0] + A[((ax0*m) + k1)])
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="numpy-style-operator-overloading">
<h2>Numpy-style operator overloading<a class="headerlink" href="#numpy-style-operator-overloading" title="Permalink to this headline">¶</a></h2>
<p>We can add two tensors using <code class="code docutils literal notranslate"><span class="pre">topi.broadcast_add</span></code> that have correct (broadcastable with specific) shapes.
Even shorter, TOPI provides operator overloading for such common operations. For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>  <span class="c1"># same as topi.broadcast_add</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>  <span class="c1"># same as topi.broadcast_mul</span>
</pre></div>
</div>
<p>Overloaded with the same syntax, TOPI handles broadcasting a primitive (<cite>int</cite>, <cite>float</cite>) to a tensor <code class="code docutils literal notranslate"><span class="pre">d</span> <span class="pre">-</span> <span class="pre">3.14</span></code>.</p>
</div>
<div class="section" id="generic-schedules-and-fusing-operations">
<h2>Generic schedules and fusing operations<a class="headerlink" href="#generic-schedules-and-fusing-operations" title="Permalink to this headline">¶</a></h2>
<p>Up to now, we have seen an example of how TOPI can save us from writing explicit computations in lower level API.
But it doesn’t stop here. Still we did the scheduling as before. TOPI also provides higher level
scheduling recipes depending on a given context. For example, for CUDA,
we can schedule the following series of operations ending with <code class="code docutils literal notranslate"><span class="pre">topi.sum</span></code> using only
<code class="code docutils literal notranslate"><span class="pre">topi.generic.schedule_reduce</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">elemwise_sum</span><span class="p">([</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">e</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">cuda</span><span class="p">():</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">generic</span><span class="o">.</span><span class="n">schedule_reduce</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tvm</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">simple_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>// attr [tensor_red] storage_scope = &quot;global&quot;
allocate tensor_red[float32 * 1]
produce tensor_red {
  // attr [iter_var(threadIdx.x, Range(min=0, extent=512), threadIdx.x)] thread_extent = 512
  // attr [tensor_red.rf] storage_scope = &quot;local&quot;
  allocate tensor_red.rf[float32 * 1]
  // attr [reduce_temp0] storage_scope = &quot;local&quot;
  allocate reduce_temp0[float32 * 1]
  produce tensor_red.rf {
    tensor_red.rf[0] = 0.000000f
    for (k0.k1.fused.k2.fused.outer, 0, 20) {
      if (((k0.k1.fused.k2.fused.outer*512) &lt; (10000 - threadIdx.x))) {
        tensor_red.rf[0] = (tensor_red.rf[0] + (((a[((k0.k1.fused.k2.fused.outer*512) + threadIdx.x)] + b[(((k0.k1.fused.k2.fused.outer*512) + threadIdx.x) % 100)]) + (a[((k0.k1.fused.k2.fused.outer*512) + threadIdx.x)]*b[(((k0.k1.fused.k2.fused.outer*512) + threadIdx.x) % 100)]))*0.500000f))
      }
    }
  }
  // attr [comm_reducer(result=[(x + y)], lhs=[x], rhs=[y], identity_element=[0.000000f])] reduce_scope = reinterpret((uint64)0)
  tvm_thread_allreduce((uint32)1, tensor_red.rf[0], (uint1)1, reduce_temp0, threadIdx.x)
  if ((threadIdx.x == 0)) {
    tensor_red[0] = reduce_temp0[0]
  }
}
</pre></div>
</div>
<p>As you can see, scheduled stages of computation have been accumulated and we can examine them by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">stages</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[stage(a, 0x3ffd2250), stage(b, 0x4fdefa20), stage(tensor, 0x58722b20), stage(tensor, 0xd4820230), stage(tensor, 0x4fdf3770), stage(tensor, 0x4fdef480), stage(tensor_red.rf, 0x5a099c30), stage(tensor_red, 0x47580250)]
</pre></div>
</div>
<p>We can test the correctness by comparing with <code class="code docutils literal notranslate"><span class="pre">numpy</span></code> result as follows</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">],</span> <span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">ctx</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">b_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">g_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a_np</span> <span class="o">+</span> <span class="n">b_np</span><span class="p">,</span> <span class="n">a_np</span> <span class="o">*</span> <span class="n">b_np</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="n">a_nd</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a_np</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
<span class="n">b_nd</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b_np</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
<span class="n">g_nd</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">g_np</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">g_np</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
<span class="n">func</span><span class="p">(</span><span class="n">a_nd</span><span class="p">,</span> <span class="n">b_nd</span><span class="p">,</span> <span class="n">g_nd</span><span class="p">)</span>
<span class="n">tvm</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">g_nd</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">g_np</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
</pre></div>
</div>
<p>TOPI also provides common neural nets operations such as _softmax_ with optimized schedule</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tarray</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;tarray&quot;</span><span class="p">)</span>
<span class="n">softmax_topi</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">tarray</span><span class="p">)</span>
<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="n">sst</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">generic</span><span class="o">.</span><span class="n">schedule_softmax</span><span class="p">(</span><span class="n">softmax_topi</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tvm</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">sst</span><span class="p">,</span> <span class="p">[</span><span class="n">tarray</span><span class="p">],</span> <span class="n">simple_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>// attr [compute] storage_scope = &quot;global&quot;
allocate compute[float32 * 512]
// attr [compute] storage_scope = &quot;global&quot;
allocate compute[float32 * 512]
// attr [compute] storage_scope = &quot;global&quot;
allocate compute[float32 * 262144]
produce compute {
  // attr [iter_var(blockIdx.x, , blockIdx.x)] thread_extent = 512
  compute[blockIdx.x] = -340282346638528859811704183484516925440.000000f
  for (k, 0, 512) {
    compute[blockIdx.x] = max(compute[blockIdx.x], tarray[((blockIdx.x*512) + k)])
  }
}
produce compute {
  // attr [iter_var(blockIdx.x, , blockIdx.x)] thread_extent = 512
  // attr [compute.rf] storage_scope = &quot;local&quot;
  allocate compute.rf[float32 * 1]
  // attr [reduce_temp0] storage_scope = &quot;local&quot;
  allocate reduce_temp0[float32 * 1]
  // attr [iter_var(threadIdx.x, Range(min=0, extent=64), threadIdx.x)] thread_extent = 64
  produce compute.rf {
    compute.rf[0] = 0.000000f
    for (k.outer, 0, 8) {
      compute.rf[0] = (compute.rf[0] + exp((tarray[((((blockIdx.x*8) + k.outer)*64) + threadIdx.x)] - compute[blockIdx.x])))
    }
  }
  // attr [comm_reducer(result=[(x + y)], lhs=[x], rhs=[y], identity_element=[0.000000f])] reduce_scope = reinterpret((uint64)0)
  tvm_thread_allreduce((uint32)1, compute.rf[0], (uint1)1, reduce_temp0, threadIdx.x)
  if ((threadIdx.x == 0)) {
    compute[blockIdx.x] = reduce_temp0[0]
  }
}
produce compute {
  // attr [iter_var(blockIdx.x, , blockIdx.x)] thread_extent = 512
  // attr [iter_var(threadIdx.x, Range(min=0, extent=64), threadIdx.x)] thread_extent = 64
  for (i1.inner, 0, 8) {
    compute[((((blockIdx.x*64) + threadIdx.x)*8) + i1.inner)] = (exp((tarray[((((blockIdx.x*64) + threadIdx.x)*8) + i1.inner)] - compute[blockIdx.x]))/compute[blockIdx.x])
  }
}
</pre></div>
</div>
</div>
<div class="section" id="fusing-convolutions">
<h2>Fusing convolutions<a class="headerlink" href="#fusing-convolutions" title="Permalink to this headline">¶</a></h2>
<p>We can fuse <code class="code docutils literal notranslate"><span class="pre">topi.nn.conv2d</span></code> and <code class="code docutils literal notranslate"><span class="pre">topi.nn.relu</span></code> together.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TOPI functions are all generic functions. They have different implementations
for different backends to optimize for performance.
For each backend, it is necessary to call them under a target scope for both
compute declaration and schedule. TVM will choose the right function to call with
the target information.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">))</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="n">conv</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">conv</span><span class="p">)</span>
    <span class="n">sconv</span> <span class="o">=</span> <span class="n">topi</span><span class="o">.</span><span class="n">generic</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">schedule_conv2d_nchw</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tvm</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">sconv</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">kernel</span><span class="p">],</span> <span class="n">simple_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>// attr [compute] storage_scope = &quot;global&quot;
allocate compute[float32 * 501760]
produce compute {
  // attr [iter_var(blockIdx.z, , blockIdx.z)] thread_extent = 5
  // attr [compute] storage_scope = &quot;local&quot;
  allocate compute[float32 * 16]
  // attr [pad_temp.shared] storage_scope = &quot;shared&quot;
  allocate pad_temp.shared[float32 * 128]
  // attr [placeholder.shared] storage_scope = &quot;shared&quot;
  allocate placeholder.shared[float32 * 2]
  // attr [iter_var(blockIdx.y, , blockIdx.y)] thread_extent = 28
  // attr [iter_var(blockIdx.x, , blockIdx.x)] thread_extent = 14
  // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
  // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
  // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
  produce compute {
    compute[0] = 0.000000f
    compute[1] = 0.000000f
    compute[2] = 0.000000f
    compute[3] = 0.000000f
    compute[4] = 0.000000f
    compute[5] = 0.000000f
    compute[6] = 0.000000f
    compute[7] = 0.000000f
    compute[8] = 0.000000f
    compute[9] = 0.000000f
    compute[10] = 0.000000f
    compute[11] = 0.000000f
    compute[12] = 0.000000f
    compute[13] = 0.000000f
    compute[14] = 0.000000f
    compute[15] = 0.000000f
    for (rc.outer, 0, 3) {
      for (ry.outer, 0, 5) {
        produce pad_temp.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          pad_temp.shared[((((threadIdx.x/16)*16) + threadIdx.x)*8)] = tvm_if_then_else(((((((2 - ry.outer) - (threadIdx.x/2)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (threadIdx.x/2)))) &amp;&amp; ((2 - ((threadIdx.x*8) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - ((threadIdx.x*8) % 16)))), placeholder[(((((((((((((threadIdx.x/16)*3) + rc.outer)*28) + blockIdx.y)*8) + (threadIdx.x/2)) + ry.outer)*14) + blockIdx.x)*16) + ((threadIdx.x*8) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 1)/128)*16) + threadIdx.x)*8) + 1)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 1)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 1)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 1) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 1) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 1)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 1)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 1) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 2)/128)*16) + threadIdx.x)*8) + 2)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 2)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 2)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 2) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 2) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 2)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 2)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 2) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 3)/128)*16) + threadIdx.x)*8) + 3)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 3)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 3)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 3) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 3) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 3)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 3)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 3) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 4)/128)*16) + threadIdx.x)*8) + 4)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 4)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 4)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 4) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 4) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 4)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 4)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 4) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 5)/128)*16) + threadIdx.x)*8) + 5)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 5)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 5)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 5) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 5) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 5)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 5)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 5) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 6)/128)*16) + threadIdx.x)*8) + 6)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 6)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 6)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 6) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 6) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 6)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 6)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 6) % 16)) + -450)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 7)/128)*16) + threadIdx.x)*8) + 7)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 7)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 7)/16)))) &amp;&amp; ((2 - (((threadIdx.x*8) + 7) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (226 - (((threadIdx.x*8) + 7) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 7)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 7)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 7) % 16)) + -450)], 0.000000f)
        }
        produce placeholder.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          if (likely((threadIdx.x &lt; 2))) {
            if (likely(((blockIdx.z*2) &lt; (10 - threadIdx.x)))) {
              placeholder.shared[threadIdx.x] = placeholder[(((((((blockIdx.z*2) + threadIdx.x)*3) + rc.outer)*5) + ry.outer)*5)]
            }
          }
        }
        compute[0] = (compute[0] + (pad_temp.shared[threadIdx.x]*placeholder.shared[0]))
        compute[1] = (compute[1] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[0]))
        compute[2] = (compute[2] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[0]))
        compute[3] = (compute[3] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[0]))
        compute[4] = (compute[4] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[0]))
        compute[5] = (compute[5] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[0]))
        compute[6] = (compute[6] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[0]))
        compute[7] = (compute[7] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[0]))
        compute[8] = (compute[8] + (pad_temp.shared[threadIdx.x]*placeholder.shared[1]))
        compute[9] = (compute[9] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[1]))
        compute[10] = (compute[10] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[1]))
        compute[11] = (compute[11] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[1]))
        compute[12] = (compute[12] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[1]))
        compute[13] = (compute[13] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[1]))
        compute[14] = (compute[14] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[1]))
        compute[15] = (compute[15] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[1]))
        produce pad_temp.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          pad_temp.shared[((((threadIdx.x/16)*16) + threadIdx.x)*8)] = tvm_if_then_else(((((((2 - ry.outer) - (threadIdx.x/2)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (threadIdx.x/2)))) &amp;&amp; ((1 - ((threadIdx.x*8) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - ((threadIdx.x*8) % 16)))), placeholder[(((((((((((((threadIdx.x/16)*3) + rc.outer)*28) + blockIdx.y)*8) + (threadIdx.x/2)) + ry.outer)*14) + blockIdx.x)*16) + ((threadIdx.x*8) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 1)/128)*16) + threadIdx.x)*8) + 1)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 1)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 1)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 1) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 1) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 1)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 1)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 1) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 2)/128)*16) + threadIdx.x)*8) + 2)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 2)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 2)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 2) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 2) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 2)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 2)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 2) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 3)/128)*16) + threadIdx.x)*8) + 3)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 3)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 3)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 3) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 3) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 3)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 3)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 3) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 4)/128)*16) + threadIdx.x)*8) + 4)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 4)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 4)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 4) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 4) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 4)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 4)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 4) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 5)/128)*16) + threadIdx.x)*8) + 5)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 5)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 5)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 5) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 5) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 5)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 5)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 5) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 6)/128)*16) + threadIdx.x)*8) + 6)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 6)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 6)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 6) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 6) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 6)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 6)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 6) % 16)) + -449)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 7)/128)*16) + threadIdx.x)*8) + 7)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 7)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 7)/16)))) &amp;&amp; ((1 - (((threadIdx.x*8) + 7) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (225 - (((threadIdx.x*8) + 7) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 7)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 7)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 7) % 16)) + -449)], 0.000000f)
        }
        produce placeholder.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          if (likely((threadIdx.x &lt; 2))) {
            if (likely(((blockIdx.z*2) &lt; (10 - threadIdx.x)))) {
              placeholder.shared[threadIdx.x] = placeholder[((((((((blockIdx.z*2) + threadIdx.x)*3) + rc.outer)*5) + ry.outer)*5) + 1)]
            }
          }
        }
        compute[0] = (compute[0] + (pad_temp.shared[threadIdx.x]*placeholder.shared[0]))
        compute[1] = (compute[1] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[0]))
        compute[2] = (compute[2] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[0]))
        compute[3] = (compute[3] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[0]))
        compute[4] = (compute[4] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[0]))
        compute[5] = (compute[5] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[0]))
        compute[6] = (compute[6] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[0]))
        compute[7] = (compute[7] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[0]))
        compute[8] = (compute[8] + (pad_temp.shared[threadIdx.x]*placeholder.shared[1]))
        compute[9] = (compute[9] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[1]))
        compute[10] = (compute[10] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[1]))
        compute[11] = (compute[11] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[1]))
        compute[12] = (compute[12] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[1]))
        compute[13] = (compute[13] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[1]))
        compute[14] = (compute[14] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[1]))
        compute[15] = (compute[15] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[1]))
        produce pad_temp.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          pad_temp.shared[((((threadIdx.x/16)*16) + threadIdx.x)*8)] = tvm_if_then_else(((((((2 - ry.outer) - (threadIdx.x/2)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (threadIdx.x/2)))) &amp;&amp; ((0 - ((threadIdx.x*8) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - ((threadIdx.x*8) % 16)))), placeholder[(((((((((((((threadIdx.x/16)*3) + rc.outer)*28) + blockIdx.y)*8) + (threadIdx.x/2)) + ry.outer)*14) + blockIdx.x)*16) + ((threadIdx.x*8) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 1)/128)*16) + threadIdx.x)*8) + 1)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 1)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 1)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 1) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 1) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 1)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 1)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 1) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 2)/128)*16) + threadIdx.x)*8) + 2)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 2)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 2)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 2) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 2) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 2)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 2)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 2) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 3)/128)*16) + threadIdx.x)*8) + 3)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 3)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 3)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 3) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 3) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 3)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 3)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 3) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 4)/128)*16) + threadIdx.x)*8) + 4)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 4)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 4)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 4) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 4) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 4)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 4)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 4) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 5)/128)*16) + threadIdx.x)*8) + 5)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 5)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 5)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 5) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 5) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 5)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 5)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 5) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 6)/128)*16) + threadIdx.x)*8) + 6)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 6)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 6)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 6) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 6) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 6)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 6)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 6) % 16)) + -448)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 7)/128)*16) + threadIdx.x)*8) + 7)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 7)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 7)/16)))) &amp;&amp; ((0 - (((threadIdx.x*8) + 7) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (224 - (((threadIdx.x*8) + 7) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 7)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 7)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 7) % 16)) + -448)], 0.000000f)
        }
        produce placeholder.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          if (likely((threadIdx.x &lt; 2))) {
            if (likely(((blockIdx.z*2) &lt; (10 - threadIdx.x)))) {
              placeholder.shared[threadIdx.x] = placeholder[((((((((blockIdx.z*2) + threadIdx.x)*3) + rc.outer)*5) + ry.outer)*5) + 2)]
            }
          }
        }
        compute[0] = (compute[0] + (pad_temp.shared[threadIdx.x]*placeholder.shared[0]))
        compute[1] = (compute[1] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[0]))
        compute[2] = (compute[2] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[0]))
        compute[3] = (compute[3] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[0]))
        compute[4] = (compute[4] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[0]))
        compute[5] = (compute[5] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[0]))
        compute[6] = (compute[6] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[0]))
        compute[7] = (compute[7] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[0]))
        compute[8] = (compute[8] + (pad_temp.shared[threadIdx.x]*placeholder.shared[1]))
        compute[9] = (compute[9] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[1]))
        compute[10] = (compute[10] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[1]))
        compute[11] = (compute[11] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[1]))
        compute[12] = (compute[12] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[1]))
        compute[13] = (compute[13] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[1]))
        compute[14] = (compute[14] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[1]))
        compute[15] = (compute[15] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[1]))
        produce pad_temp.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          pad_temp.shared[((((threadIdx.x/16)*16) + threadIdx.x)*8)] = tvm_if_then_else(((((((2 - ry.outer) - (threadIdx.x/2)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (threadIdx.x/2)))) &amp;&amp; ((-1 - ((threadIdx.x*8) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - ((threadIdx.x*8) % 16)))), placeholder[(((((((((((((threadIdx.x/16)*3) + rc.outer)*28) + blockIdx.y)*8) + (threadIdx.x/2)) + ry.outer)*14) + blockIdx.x)*16) + ((threadIdx.x*8) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 1)/128)*16) + threadIdx.x)*8) + 1)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 1)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 1)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 1) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 1) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 1)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 1)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 1) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 2)/128)*16) + threadIdx.x)*8) + 2)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 2)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 2)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 2) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 2) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 2)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 2)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 2) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 3)/128)*16) + threadIdx.x)*8) + 3)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 3)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 3)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 3) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 3) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 3)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 3)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 3) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 4)/128)*16) + threadIdx.x)*8) + 4)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 4)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 4)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 4) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 4) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 4)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 4)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 4) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 5)/128)*16) + threadIdx.x)*8) + 5)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 5)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 5)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 5) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 5) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 5)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 5)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 5) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 6)/128)*16) + threadIdx.x)*8) + 6)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 6)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 6)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 6) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 6) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 6)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 6)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 6) % 16)) + -447)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 7)/128)*16) + threadIdx.x)*8) + 7)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 7)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 7)/16)))) &amp;&amp; ((-1 - (((threadIdx.x*8) + 7) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (223 - (((threadIdx.x*8) + 7) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 7)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 7)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 7) % 16)) + -447)], 0.000000f)
        }
        produce placeholder.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          if (likely((threadIdx.x &lt; 2))) {
            if (likely(((blockIdx.z*2) &lt; (10 - threadIdx.x)))) {
              placeholder.shared[threadIdx.x] = placeholder[((((((((blockIdx.z*2) + threadIdx.x)*3) + rc.outer)*5) + ry.outer)*5) + 3)]
            }
          }
        }
        compute[0] = (compute[0] + (pad_temp.shared[threadIdx.x]*placeholder.shared[0]))
        compute[1] = (compute[1] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[0]))
        compute[2] = (compute[2] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[0]))
        compute[3] = (compute[3] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[0]))
        compute[4] = (compute[4] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[0]))
        compute[5] = (compute[5] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[0]))
        compute[6] = (compute[6] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[0]))
        compute[7] = (compute[7] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[0]))
        compute[8] = (compute[8] + (pad_temp.shared[threadIdx.x]*placeholder.shared[1]))
        compute[9] = (compute[9] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[1]))
        compute[10] = (compute[10] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[1]))
        compute[11] = (compute[11] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[1]))
        compute[12] = (compute[12] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[1]))
        compute[13] = (compute[13] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[1]))
        compute[14] = (compute[14] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[1]))
        compute[15] = (compute[15] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[1]))
        produce pad_temp.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          pad_temp.shared[((((threadIdx.x/16)*16) + threadIdx.x)*8)] = tvm_if_then_else(((((((2 - ry.outer) - (threadIdx.x/2)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (threadIdx.x/2)))) &amp;&amp; ((-2 - ((threadIdx.x*8) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - ((threadIdx.x*8) % 16)))), placeholder[(((((((((((((threadIdx.x/16)*3) + rc.outer)*28) + blockIdx.y)*8) + (threadIdx.x/2)) + ry.outer)*14) + blockIdx.x)*16) + ((threadIdx.x*8) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 1)/128)*16) + threadIdx.x)*8) + 1)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 1)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 1)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 1) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 1) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 1)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 1)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 1) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 2)/128)*16) + threadIdx.x)*8) + 2)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 2)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 2)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 2) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 2) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 2)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 2)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 2) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 3)/128)*16) + threadIdx.x)*8) + 3)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 3)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 3)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 3) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 3) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 3)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 3)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 3) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 4)/128)*16) + threadIdx.x)*8) + 4)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 4)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 4)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 4) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 4) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 4)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 4)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 4) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 5)/128)*16) + threadIdx.x)*8) + 5)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 5)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 5)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 5) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 5) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 5)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 5)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 5) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 6)/128)*16) + threadIdx.x)*8) + 6)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 6)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 6)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 6) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 6) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 6)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 6)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 6) % 16)) + -446)], 0.000000f)
          pad_temp.shared[(((((((threadIdx.x*8) + 7)/128)*16) + threadIdx.x)*8) + 7)] = tvm_if_then_else(((((((2 - ry.outer) - (((threadIdx.x*8) + 7)/16)) &lt;= (blockIdx.y*8)) &amp;&amp; ((blockIdx.y*8) &lt; ((226 - ry.outer) - (((threadIdx.x*8) + 7)/16)))) &amp;&amp; ((-2 - (((threadIdx.x*8) + 7) % 16)) &lt;= (blockIdx.x*16))) &amp;&amp; ((blockIdx.x*16) &lt; (222 - (((threadIdx.x*8) + 7) % 16)))), placeholder[(((((((((((((((threadIdx.x*8) + 7)/128)*3) + rc.outer)*28) + blockIdx.y)*8) + (((threadIdx.x*8) + 7)/16)) + ry.outer)*14) + blockIdx.x)*16) + (((threadIdx.x*8) + 7) % 16)) + -446)], 0.000000f)
        }
        produce placeholder.shared {
          // attr [iter_var(threadIdx.z, , threadIdx.z)] thread_extent = 1
          // attr [iter_var(threadIdx.y, , threadIdx.y)] thread_extent = 1
          // attr [iter_var(threadIdx.x, , threadIdx.x)] thread_extent = 16
          if (likely((threadIdx.x &lt; 2))) {
            if (likely(((blockIdx.z*2) &lt; (10 - threadIdx.x)))) {
              placeholder.shared[threadIdx.x] = placeholder[((((((((blockIdx.z*2) + threadIdx.x)*3) + rc.outer)*5) + ry.outer)*5) + 4)]
            }
          }
        }
        compute[0] = (compute[0] + (pad_temp.shared[threadIdx.x]*placeholder.shared[0]))
        compute[1] = (compute[1] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[0]))
        compute[2] = (compute[2] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[0]))
        compute[3] = (compute[3] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[0]))
        compute[4] = (compute[4] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[0]))
        compute[5] = (compute[5] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[0]))
        compute[6] = (compute[6] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[0]))
        compute[7] = (compute[7] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[0]))
        compute[8] = (compute[8] + (pad_temp.shared[threadIdx.x]*placeholder.shared[1]))
        compute[9] = (compute[9] + (pad_temp.shared[(threadIdx.x + 16)]*placeholder.shared[1]))
        compute[10] = (compute[10] + (pad_temp.shared[(threadIdx.x + 32)]*placeholder.shared[1]))
        compute[11] = (compute[11] + (pad_temp.shared[(threadIdx.x + 48)]*placeholder.shared[1]))
        compute[12] = (compute[12] + (pad_temp.shared[(threadIdx.x + 64)]*placeholder.shared[1]))
        compute[13] = (compute[13] + (pad_temp.shared[(threadIdx.x + 80)]*placeholder.shared[1]))
        compute[14] = (compute[14] + (pad_temp.shared[(threadIdx.x + 96)]*placeholder.shared[1]))
        compute[15] = (compute[15] + (pad_temp.shared[(threadIdx.x + 112)]*placeholder.shared[1]))
      }
    }
  }
  compute[((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x)] = max(compute[0], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 224)] = max(compute[1], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 448)] = max(compute[2], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 672)] = max(compute[3], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 896)] = max(compute[4], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 1120)] = max(compute[5], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 1344)] = max(compute[6], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 1568)] = max(compute[7], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 50176)] = max(compute[8], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 50400)] = max(compute[9], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 50624)] = max(compute[10], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 50848)] = max(compute[11], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 51072)] = max(compute[12], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 51296)] = max(compute[13], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 51520)] = max(compute[14], 0.000000f)
  compute[(((((((blockIdx.z*56) + blockIdx.y)*112) + blockIdx.x)*16) + threadIdx.x) + 51744)] = max(compute[15], 0.000000f)
}
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In this tutorial, we have seen</p>
<ul class="simple">
<li>How to use TOPI API for common operations with numpy-style operators.</li>
<li>How TOPI facilitates generic schedules and operator fusion for a context, to generate optimized kernel codes.</li>
</ul>
<p><strong>Total running time of the script:</strong> ( 0 minutes  0.522 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-tutorials-topi-intro-topi-py">
<div class="sphx-glr-download docutils container">
<a class="reference download internal" download="" href="../../_downloads/c86c6411d245097b7da80033aa6e27ae/intro_topi.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">intro_topi.py</span></code></a></div>
<div class="sphx-glr-download docutils container">
<a class="reference download internal" download="" href="../../_downloads/2263f8127e4f99f54eff8cd5610d47af/intro_topi.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">intro_topi.ipynb</span></code></a></div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.readthedocs.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../vta/index.html" class="btn btn-neutral float-right" title="VTA: Deep Learning Accelerator Stack" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../dev/low_level_custom_pass.html" class="btn btn-neutral float-left" title="Writing a Customized Pass" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, tvm developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>