

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TVM Codebase Walkthrough by Example &mdash; tvm 0.6.dev documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/tvm_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="NNVM Core Tensor Operators" href="../nnvm_top.html" />
    <link rel="prev" title="Adding an Operator to Relay" href="relay_add_op.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.6.dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vta/index.html">VTA: Deep Learning Accelerator Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deploy/index.html">Deploy and Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribute to TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../langref/index.html">Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/python/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_links.html">Links to API References</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design and Developer Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="runtime.html">TVM Runtime System</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugger.html"><strong>Debugger</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="nnvm_json_spec.html">NNVM Graph JSON Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="nnvm_overview.html">NNVM Design Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="hybrid_script.html">Hybrid Frontend Developer Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay_intro.html">Introduction to Relay IR</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay_add_op.html">Adding an Operator to Relay</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><strong>TVM Codebase Walkthrough by Example</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#codebase-structure-overview">Codebase Structure Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vector-add-example">Vector Add Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../nnvm_top.html">NNVM Core Tensor Operators</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">tvm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Design and Developer Guide</a> &raquo;</li>
        
      <li><strong>TVM Codebase Walkthrough by Example</strong></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/dev/codebase_walkthrough.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tvm-codebase-walkthrough-by-example">
<h1><strong>TVM Codebase Walkthrough by Example</strong><a class="headerlink" href="#tvm-codebase-walkthrough-by-example" title="Permalink to this headline">¶</a></h1>
<p>Getting to know a new codebase can be a challenge. This is especially true for a codebase like that of TVM, where different components interact in non-obvious ways. In this guide, we try to illustrate the key elements that comprise a compilation pipeline with a simple example. For each important step, we show where in the codebase it is implemented. The purpose is to let new developers and interested users dive into the codebase more quickly.</p>
<div class="section" id="codebase-structure-overview">
<h2>Codebase Structure Overview<a class="headerlink" href="#codebase-structure-overview" title="Permalink to this headline">¶</a></h2>
<p>At the root of the TVM repository, we have following subdirectories that together comprise a bulk of the codebase.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code> - C++ code for operator compilation and deployment runtimes.</li>
<li><code class="docutils literal notranslate"><span class="pre">src/relay</span></code> - Implementation of Relay, a new IR for deep learning framework superseding <code class="docutils literal notranslate"><span class="pre">nnvm</span></code> below.</li>
<li><code class="docutils literal notranslate"><span class="pre">python</span></code> - Python frontend that wraps C++ functions and objects implemented in <code class="docutils literal notranslate"><span class="pre">src</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">topi</span></code> - Compute definitions and backend schedules for standard neural network operators.</li>
<li><code class="docutils literal notranslate"><span class="pre">nnvm</span></code> - C++ code and Python frontend for graph optimization and compilation. After the introduction of Relay, it remains in the codebase for backward compatibility.</li>
</ul>
<p>Using standard Deep Learning terminologies, <code class="docutils literal notranslate"><span class="pre">src/relay</span></code> is the component that manages a computational graph, and nodes in a graph are compiled and executed using infrastructures implemented in the rest of <code class="docutils literal notranslate"><span class="pre">src</span></code>. <code class="docutils literal notranslate"><span class="pre">python</span></code> provides python bindings for the C++ API and driver code that users can use to execute compilation. Operators corresponding to each node are registered in <code class="docutils literal notranslate"><span class="pre">src/relay/op</span></code>. Implementations for operators are in <code class="docutils literal notranslate"><span class="pre">topi</span></code>, and they are coded in either C++ or Python.</p>
<p>Relay is the new IR for deep networks that is intended to replace NNVM. If you have used NNVM, Relay provides equivalent or better functionalities. In fact, Relay goes beyond a traditional way of thinking deep networks in terms of computational graphs. But for the purpose of this document, we can think of Relay as a traditional computational graph framework. You can read more about Relay <a class="reference external" href="https://docs.tvm.ai/dev/relay_intro.html">here</a>.</p>
<p>When a user invokes graph compilation by <code class="docutils literal notranslate"><span class="pre">relay.build(...)</span></code> (or <code class="docutils literal notranslate"><span class="pre">nnvm.compiler.build(...)</span></code> for the older API), the following sequence of actions happens for each node in the graph:</p>
<ul class="simple">
<li>Look up an operator implementation by querying the operator registry</li>
<li>Generate a compute expression and a schdule for the operator</li>
<li>Compile the operator into object code</li>
</ul>
<p>One of the interesting aspects of TVM codebase is that interop between C++ and Python is not unidirectional. Typically, all code that do heavy liftings are implemented in C++, and Python bindings are provided for user interface. This is also true in TVM, but in TVM codebase, C++ code also call into functions defined in a Python module. For example, the convolution operator is implemented in Python, and its implementation is invoked from C++ code in Relay.</p>
</div>
<div class="section" id="vector-add-example">
<h2>Vector Add Example<a class="headerlink" href="#vector-add-example" title="Permalink to this headline">¶</a></h2>
<p>We use a simple example that uses the low level TVM API directly. The example is vector addition, which is covered in detail in <a class="reference external" href="https://docs.tvm.ai/tutorials/get_started.html#sphx-glr-tutorials-get-started-py">this tutorial</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">placeholder</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, types of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code> are <code class="docutils literal notranslate"><span class="pre">tvm.tensor.Tensor</span></code>, defined in <code class="docutils literal notranslate"><span class="pre">python/tvm/tensor.py</span></code>. The Python <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> is backed by C++ <code class="docutils literal notranslate"><span class="pre">Tensor</span></code>, implemented in <code class="docutils literal notranslate"><span class="pre">include/tvm/tensor.h</span></code> and <code class="docutils literal notranslate"><span class="pre">src/lang/tensor.cc</span></code>. All Python types in TVM can be thought of as a handle to the underlying C++ type with the same name. If you look at the definition of Python <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> type below, you can see it is a subclass of <code class="docutils literal notranslate"><span class="pre">NodeBase</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@register_node</span>
<span class="k">class</span> <span class="nc">Tensor</span><span class="p">(</span><span class="n">NodeBase</span><span class="p">,</span> <span class="n">_expr</span><span class="o">.</span><span class="n">ExprOp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tensor object, to construct, see function.Tensor&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">):</span>
       <span class="o">...</span>
</pre></div>
</div>
<p>The Node system is the basis of exposing C++ types to frontend languages, including Python. The way TVM implements Python wrapping is not straightforward. It is briefly covered in <a class="reference external" href="https://docs.tvm.ai/dev/runtime.html#tvm-node-and-compiler-stack">this document</a>, and details are in <code class="docutils literal notranslate"><span class="pre">python/tvm/_ffi/</span></code> if you are interested.</p>
<p><code class="docutils literal notranslate"><span class="pre">Tensor</span></code> is created by functions in <code class="docutils literal notranslate"><span class="pre">python/tvm/api.py</span></code>, which in turn calls into C++ functions exposed in <code class="docutils literal notranslate"><span class="pre">src/api/api_lang.cc</span></code>. All C++ functions that are callable from Python are exposed in the <code class="docutils literal notranslate"><span class="pre">src/api</span></code> subdirectory. For example, the <code class="docutils literal notranslate"><span class="pre">tvm.compute()</span></code> function above calls into <code class="docutils literal notranslate"><span class="pre">_ComputeOp</span></code> api exposed in <code class="docutils literal notranslate"><span class="pre">src/api/api_lang.cc</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TVM_REGISTER_API</span><span class="p">(</span><span class="s2">&quot;_ComputeOp&quot;</span><span class="p">)</span>
<span class="o">.</span><span class="n">set_body</span><span class="p">([](</span><span class="n">TVMArgs</span> <span class="n">args</span><span class="p">,</span>  <span class="n">TVMRetValue</span><span class="o">*</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ComputeOpNode</span><span class="p">::</span><span class="n">make</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                               <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                               <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
  <span class="p">});</span>
</pre></div>
</div>
<p>We use <code class="docutils literal notranslate"><span class="pre">TVM_REGISTER_*</span></code> macro to expose C++ functions to frontend languages, in the form of <a class="reference external" href="https://docs.tvm.ai/dev/runtime.html#packedfunc">PackedFunc</a>. <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code> is another mechanism by which TVM implements C++ and Python interop. In particular, this is what makes calling Python functions from the C++ codebase very easy.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> object has an <code class="docutils literal notranslate"><span class="pre">Operation</span></code> object associated with it, defined in <code class="docutils literal notranslate"><span class="pre">python/tvm/tensor.py</span></code>, <code class="docutils literal notranslate"><span class="pre">include/tvm/operation.h</span></code>, and <code class="docutils literal notranslate"><span class="pre">src/tvm/op</span></code> subdirectory. A <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> is an output of its <code class="docutils literal notranslate"><span class="pre">Operation</span></code> object. Each <code class="docutils literal notranslate"><span class="pre">Operation</span></code> object has in turn <code class="docutils literal notranslate"><span class="pre">input_tensors()</span></code> method, which returns a list of input <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> to it. This way we can keep track of dependencies between <code class="docutils literal notranslate"><span class="pre">Operation</span></code>.</p>
<p>We pass the operation corresponding to the output tensor <code class="docutils literal notranslate"><span class="pre">C</span></code> to <code class="docutils literal notranslate"><span class="pre">tvm.create_schedule()</span></code> function in <code class="docutils literal notranslate"><span class="pre">python/tvm/schedule.py</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>This function is mapped to the C++ function in <code class="docutils literal notranslate"><span class="pre">include/tvm/schedule.h</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inline</span> <span class="n">Schedule</span> <span class="n">create_schedule</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">&gt;</span> <span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">ScheduleNode</span><span class="p">::</span><span class="n">make</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Schedule</span></code> consists of collections of <code class="docutils literal notranslate"><span class="pre">Stage</span></code> and output <code class="docutils literal notranslate"><span class="pre">Operation</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Stage</span></code> corresponds to one <code class="docutils literal notranslate"><span class="pre">Operation</span></code>. In the vector add example above, there are two placeholder ops and one compute op, so the schedule <code class="docutils literal notranslate"><span class="pre">s</span></code> contains three stages. Each <code class="docutils literal notranslate"><span class="pre">Stage</span></code> holds information about a loop nest structure, types of each loop (<code class="docutils literal notranslate"><span class="pre">Parallel</span></code>, <code class="docutils literal notranslate"><span class="pre">Vectorized</span></code>, <code class="docutils literal notranslate"><span class="pre">Unrolled</span></code>), and where to execute its computation in the loop nest of the next <code class="docutils literal notranslate"><span class="pre">Stage</span></code>, if any.</p>
<p><code class="docutils literal notranslate"><span class="pre">Schedule</span></code> and <code class="docutils literal notranslate"><span class="pre">Stage</span></code> are defined in <code class="docutils literal notranslate"><span class="pre">tvm/python/schedule.py</span></code>, <code class="docutils literal notranslate"><span class="pre">include/tvm/schedule.h</span></code>, and <code class="docutils literal notranslate"><span class="pre">src/schedule/schedule_ops.cc</span></code>.</p>
<p>To keep it simple, we call <code class="docutils literal notranslate"><span class="pre">tvm.build(...)</span></code> on the default schedule created by <code class="docutils literal notranslate"><span class="pre">create_schedule()</span></code> function above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span>
<span class="n">fadd</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tvm.build()</span></code>, defined in <code class="docutils literal notranslate"><span class="pre">python/tvm/build_module.py</span></code>, takes a schedule, input and output <code class="docutils literal notranslate"><span class="pre">Tensor</span></code>, and a target, and returns a <code class="docutils literal notranslate"><span class="pre">tvm.Module</span></code> object, defined in <code class="docutils literal notranslate"><span class="pre">python/tvm/module.py</span></code>. A <code class="docutils literal notranslate"><span class="pre">Module</span></code> object contains a compiled function which can be invoked with function call syntax.</p>
<p>The process of <code class="docutils literal notranslate"><span class="pre">tvm.build()</span></code> can be divided into two steps:</p>
<ul class="simple">
<li>Lowering, where a high level, initial loop nest structures are transformed into a final, low level IR</li>
<li>Code generation, where target machine code is generated from the low level IR</li>
</ul>
<p>Lowering is done by <code class="docutils literal notranslate"><span class="pre">tvm.lower()</span></code> function, defined in <code class="docutils literal notranslate"><span class="pre">python/tvm/build_module.py</span></code>. First, bound inference is peformed, and an initial loop nest structure is created.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span>
          <span class="n">args</span><span class="p">,</span>
          <span class="n">name</span><span class="o">=</span><span class="s2">&quot;default_function&quot;</span><span class="p">,</span>
          <span class="n">binds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">simple_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
   <span class="o">...</span>
   <span class="n">bounds</span> <span class="o">=</span> <span class="n">schedule</span><span class="o">.</span><span class="n">InferBound</span><span class="p">(</span><span class="n">sch</span><span class="p">)</span>
   <span class="n">stmt</span> <span class="o">=</span> <span class="n">schedule</span><span class="o">.</span><span class="n">ScheduleOps</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>Bound inference is the process where all loop bounds and sizes of intermidiate buffers are inferred. If you target the CUDA backend and you use shared memory, its required minimum size is automatically determined here. Bound inference is implemented in <code class="docutils literal notranslate"><span class="pre">src/schedule/bound.cc</span></code>, <code class="docutils literal notranslate"><span class="pre">src/schedule/graph.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">src/schedule/message_passing.cc</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">stmt</span></code>, which is the output of <code class="docutils literal notranslate"><span class="pre">ScheduleOps()</span></code>, represents an initial loop nest structure. If you have applied <code class="docutils literal notranslate"><span class="pre">reorder</span></code> or <code class="docutils literal notranslate"><span class="pre">split</span></code> primitives to your schedule, then the initial loop nest already reflects that changes. <code class="docutils literal notranslate"><span class="pre">ScheduleOps()</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">src/schedule/schedule_ops.cc</span></code>.</p>
<p>Next, we apply a number of lowering passes to <code class="docutils literal notranslate"><span class="pre">stmt</span></code>. These passes are implemented in <code class="docutils literal notranslate"><span class="pre">src/pass</span></code> subdirectory. For example, if you have applied <code class="docutils literal notranslate"><span class="pre">vectorize</span></code> or <code class="docutils literal notranslate"><span class="pre">unroll</span></code> primitives to your schedule, they are applied in loop vectorization and unrolling passes below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">ir_pass</span><span class="o">.</span><span class="n">VectorizeLoop</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">ir_pass</span><span class="o">.</span><span class="n">UnrollLoop</span><span class="p">(</span>
    <span class="n">stmt</span><span class="p">,</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">auto_unroll_max_step</span><span class="p">,</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">auto_unroll_max_depth</span><span class="p">,</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">auto_unroll_max_extent</span><span class="p">,</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">unroll_explicit</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>After lowering is done, <code class="docutils literal notranslate"><span class="pre">build()</span></code> function generates target machine code from the lowered function. This code can contain SSE or AVX instructions if you target x86, or PTX instructions for CUDA target. In addition to target specific machine code, TVM also generates host side code that is responsible for memory management, kernel launch etc.</p>
<p>Code generation is done by <code class="docutils literal notranslate"><span class="pre">build_module()</span></code> function, defined in <code class="docutils literal notranslate"><span class="pre">python/tvm/codege.py</span></code>. On the C++ side, code generation is implemented in <code class="docutils literal notranslate"><span class="pre">src/codegen</span></code> subdirectory. <code class="docutils literal notranslate"><span class="pre">build_module()</span></code> Python function will reach <code class="docutils literal notranslate"><span class="pre">Build()</span></code> function below in <code class="docutils literal notranslate"><span class="pre">src/codegen/codegen.cc</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="p">::</span><span class="n">Module</span> <span class="n">Build</span><span class="p">(</span><span class="n">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">LoweredFunc</span><span class="o">&gt;&amp;</span> <span class="n">funcs</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">build_f_name</span> <span class="o">=</span> <span class="s2">&quot;codegen.build_&quot;</span> <span class="o">+</span> <span class="n">target</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">PackedFunc</span><span class="o">*</span> <span class="n">bf</span> <span class="o">=</span> <span class="n">runtime</span><span class="p">::</span><span class="n">Registry</span><span class="p">::</span><span class="n">Get</span><span class="p">(</span><span class="n">build_f_name</span><span class="p">);</span>
  <span class="n">runtime</span><span class="p">::</span><span class="n">Module</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bf</span><span class="p">)(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Build()</span></code> function looks up the code generator for the given target in the <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code> registry, and invokes the function found. For example, <code class="docutils literal notranslate"><span class="pre">codegen.build_cuda</span></code> function is registered in <code class="docutils literal notranslate"><span class="pre">src/codegen/build_cuda_on.cc</span></code>, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TVM_REGISTER_API</span><span class="p">(</span><span class="s2">&quot;codegen.build_cuda&quot;</span><span class="p">)</span>
<span class="o">.</span><span class="n">set_body</span><span class="p">([](</span><span class="n">TVMArgs</span> <span class="n">args</span><span class="p">,</span> <span class="n">TVMRetValue</span><span class="o">*</span> <span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">rv</span> <span class="o">=</span> <span class="n">BuildCUDA</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BuildCUDA()</span></code> above generates CUDA kernel source from the lowered IR using <code class="docutils literal notranslate"><span class="pre">CodeGenCUDA</span></code> class defined in <code class="docutils literal notranslate"><span class="pre">src/codegen/codegen_cuda.cc</span></code>, and compile the kernel using NVRTC. If you target a backend that uses LLVM, which includes x86, ARM, NVPTX and AMDGPU, code generation is done primarily by <code class="docutils literal notranslate"><span class="pre">CodeGenLLVM</span></code> class defined in <code class="docutils literal notranslate"><span class="pre">src/codegen/llvm/codegen_llvm.cc</span></code>. <code class="docutils literal notranslate"><span class="pre">CodeGenLLVM</span></code> translates TVM IR into LLVM IR, runs a number of LLVM optimization passes, and generates target machine code.</p>
<p><code class="docutils literal notranslate"><span class="pre">Build()</span></code> function in <code class="docutils literal notranslate"><span class="pre">src/codegen/codegen.cc</span></code> returns a <code class="docutils literal notranslate"><span class="pre">runtime::Module</span></code> object, defined in <code class="docutils literal notranslate"><span class="pre">include/tvm/runtime/module.h</span></code> and <code class="docutils literal notranslate"><span class="pre">src/runtime/module.cc</span></code>. A <code class="docutils literal notranslate"><span class="pre">Module</span></code> object is a container for the underlying target specific <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> object. Each backend implements a subclass of <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> to add target specific runtime API calls. For example, the CUDA backend implements <code class="docutils literal notranslate"><span class="pre">CUDAModuleNode</span></code> class in <code class="docutils literal notranslate"><span class="pre">src/runtime/cuda/cuda_module.cc</span></code>, which manages CUDA driver API. <code class="docutils literal notranslate"><span class="pre">BuildCUDA()</span></code> function above wraps <code class="docutils literal notranslate"><span class="pre">CUDAModuleNode</span></code> with <code class="docutils literal notranslate"><span class="pre">runtime::Module</span></code> and return it to the Python side. The LLVM backend implements <code class="docutils literal notranslate"><span class="pre">LLVMModuleNode</span></code> in <code class="docutils literal notranslate"><span class="pre">src/codegen/llvm/llvm_module.cc</span></code>, which handles JIT execution of compiled code. Other subclasses of <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> can be found under subdirectories of <code class="docutils literal notranslate"><span class="pre">src/runtime</span></code> corresponding to each backend.</p>
<p>The returned module, which can be thought of as a combination of a compiled function and a device API, can be invoked on TVM’s NDArray objects.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
<span class="n">fadd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
</pre></div>
</div>
<p>Under the hood, TVM allocates device memory and manages memory transfers automatically. To do that, each backend needs to subclass <code class="docutils literal notranslate"><span class="pre">DeviceAPI</span></code> class, defined in <code class="docutils literal notranslate"><span class="pre">include/tvm/runtime/device_api.h</span></code>, and override memory management methods to use device specific API. For example, the CUDA backend implements <code class="docutils literal notranslate"><span class="pre">CUDADeviceAPI</span></code> in <code class="docutils literal notranslate"><span class="pre">src/runtime/cuda/cuda_device_api.cc</span></code> to use <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemcpy</span></code> etc.</p>
<p>The first time you invoke the compiled module with <code class="docutils literal notranslate"><span class="pre">fadd(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>, <code class="docutils literal notranslate"><span class="pre">GetFunction()</span></code> method of <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> is called to get a <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code> that can be used for a kernel call. For example, in <code class="docutils literal notranslate"><span class="pre">src/runtime/cuda/cuda_module.cc</span></code> the CUDA backend implements <code class="docutils literal notranslate"><span class="pre">CUDAModuleNode::GetFunction()</span></code> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PackedFunc</span> <span class="n">CUDAModuleNode</span><span class="p">::</span><span class="n">GetFunction</span><span class="p">(</span>
      <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
      <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ModuleNode</span><span class="o">&gt;&amp;</span> <span class="n">sptr_to_self</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">fmap_</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">FunctionInfo</span><span class="o">&amp;</span> <span class="n">info</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
  <span class="n">CUDAWrappedFunc</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">f</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">sptr_to_self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">arg_types</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">info</span><span class="o">.</span><span class="n">thread_axis_tags</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">PackFuncVoidAddr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">arg_types</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code>’s overloaded <code class="docutils literal notranslate"><span class="pre">operator()</span></code> will be called, which in turn calls <code class="docutils literal notranslate"><span class="pre">operator()</span></code> of <code class="docutils literal notranslate"><span class="pre">CUDAWrappedFunc</span></code> in <code class="docutils literal notranslate"><span class="pre">src/runtime/cuda/cuda_module.cc</span></code>, where finally we see the <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel</span></code> driver call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CUDAWrappedFunc</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">Init</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="n">void</span> <span class="n">operator</span><span class="p">()(</span><span class="n">TVMArgs</span> <span class="n">args</span><span class="p">,</span>
                  <span class="n">TVMRetValue</span><span class="o">*</span> <span class="n">rv</span><span class="p">,</span>
                  <span class="n">void</span><span class="o">**</span> <span class="n">void_args</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">device_id</span><span class="p">;</span>
    <span class="n">CUDA_CALL</span><span class="p">(</span><span class="n">cudaGetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_id</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fcache_</span><span class="p">[</span><span class="n">device_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fcache_</span><span class="p">[</span><span class="n">device_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_</span><span class="o">-&gt;</span><span class="n">GetFunc</span><span class="p">(</span><span class="n">device_id</span><span class="p">,</span> <span class="n">func_name_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">CUstream</span> <span class="n">strm</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">CUstream</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CUDAThreadEntry</span><span class="p">::</span><span class="n">ThreadLocal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">);</span>
    <span class="n">ThreadWorkLoad</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">thread_axis_cfg_</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="n">CUresult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cuLaunchKernel</span><span class="p">(</span>
        <span class="n">fcache_</span><span class="p">[</span><span class="n">device_id</span><span class="p">],</span>
        <span class="n">wl</span><span class="o">.</span><span class="n">grid_dim</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">wl</span><span class="o">.</span><span class="n">grid_dim</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">wl</span><span class="o">.</span><span class="n">grid_dim</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">wl</span><span class="o">.</span><span class="n">block_dim</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">wl</span><span class="o">.</span><span class="n">block_dim</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">wl</span><span class="o">.</span><span class="n">block_dim</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">strm</span><span class="p">,</span> <span class="n">void_args</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This concludes an overview of how TVM compiles and executes a function. Although we did not detail TOPI or Relay, at the end all neural network operators go through the same compilation process as above. You are encouraged to dive into the details of the rest of the codebase.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../nnvm_top.html" class="btn btn-neutral float-right" title="NNVM Core Tensor Operators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="relay_add_op.html" class="btn btn-neutral float-left" title="Adding an Operator to Relay" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, tvm developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>